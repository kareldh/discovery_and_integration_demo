{"version":3,"sources":["components/TileView.js","utils/Integration/Data/ParseData.js","utils/Integration/OpenLR/map/Enum.js","utils/Integration/OpenLR/coder/CoderSettings.js","utils/Integration/OpenLR/map/Node.js","utils/Integration/OpenLR/map/Line.js","utils/Integration/OpenLR/test/Helperfunctions.js","utils/Integration/OpenLRIntegration/FOWmappings/OsmFowHighwayMapping.js","utils/Integration/OpenLRIntegration/FRCmappings/OsmFrcHighwayMapping.js","utils/Integration/OpenLRIntegration/OSMIntegration.js","utils/Integration/OpenLR/coder/Dijkstra.js","utils/Integration/OpenLR/coder/LineDecoder.js","utils/Integration/OpenLR/Decoder.js","utils/Integration/OpenLR/coder/LocationReferencePoint.js","utils/Integration/OpenLR/coder/LRPNodeHelper.js","utils/Integration/OpenLR/coder/LineEncoder.js","utils/Integration/OpenLR/SearchTree/GeoJSONRbushSearchTree.js","utils/Integration/OpenLR/SearchTree/GeoJSONRbushNodeSearchTree.js","utils/Integration/OpenLR/SearchTree/GeoJSONRbushLineSearchTree.js","utils/Integration/OpenLR/map/MapDataBase.js","utils/Integration/OpenLRIntegration/RoutableTilesIntegration.js","utils/Integration/Data/const.js","utils/Integration/Data/LoadData.js","utils/Integration/OpenLRIntegration/FRCmappings/WegenregisterAntwerpenFrcWegcatMapping.js","utils/Integration/OpenLRIntegration/FOWmappings/WegenregisterAntwerpenFowMorfMapping.js","utils/Integration/OpenLRIntegration/WegenregisterAntwerpenIntegration.js","utils/Integration/OpenLRIntegration/GeoJsonIntegration.js","utils/Integration/Data/testdata/junction_with_lanes_manual.js","utils/Integration/OpenLR/experimental/LinesDirectlyToLRPs.js","Logic/tileUtils.js","utils/OpenTrafficLights/testdata/latest.js","utils/Discovery/TrafficLightDataDiscovery/searchTree/GeoJSONRBushPolygonSearchTree.js","utils/Discovery/TrafficLightDataDiscovery/Catalog.js","utils/Discovery/TrafficLightDataDiscovery/Parser.js","utils/Discovery/TrafficLightDataDiscovery/Data.js","utils/Discovery/TrafficLightDataDiscovery/Api.js","utils/download.js","utils/OpenTrafficLights/linestringToLatLng.js","utils/OpenTrafficLights/GeoFunctions.js","utils/OpenTrafficLights/parser.js","components/MainDemo.js","components/OpenLrDemo.js","utils/OpenTrafficLights/data.js","components/NavBar.js","App.js","serviceWorker.js","index.js"],"names":["TileView","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","zoom","state","data","lat","lng","handleMouseClick","bind","assertThisInitialized","newProps","setState","ev","undefined","onMouseClick","latlng","position","react_default","a","createElement","Map","style","height","center","onClick","TileLayer","attribution","url","React","Component","getRoutableTilesNodesAndLines","triples","Promise","resolve","nodes","ways","prevInternalNodeID","currentWayElement","forEach","element","subject","predicate","object","foundNodeInObject","exec","value","foundNodeInSubject","foundWayInSubject","id","ref","push","console","warn","Number","long","toString","match","indexOf","res","split","Error","lines","fowEnum","freeze","UNDEFINED","MOTORWAY","MULTIPLE_CARRIAGEWAY","SINGLE_CARRIAGEWAY","ROUNDABOUT","TRAFFICSQUARE","SLIPROAD","OTHER","frcEnum","FRC_0","FRC_1","FRC_2","FRC_3","FRC_4","FRC_5","FRC_6","FRC_7","locationTypeEnum","UNKNOWN","LINE_LOCATION","GEO_COORDINATES","POINT_ALONG_LINE","POI_WITH_ACCESS_POINT","CIRCLE","POLYGON","CLOSED_LINE","RECTANGLE","GRID","internalPrecisionEnum","METER","CENTIMETER","decoderProperties","dist","bearDiff","frcDiff","lfrcnpDiff","distanceToNextDiff","alwaysUseProjections","useFrcFow","distMultiplier","frcMultiplier","fowMultiplier","bearMultiplier","maxSPSearchRetries","maxDecodeRetries","distMultiplierForRetry","configProperties","bearDist","internalPrecision","Node","arguments","length","incomingLines","outgoingLines","setLines","from","point","to","Math","round","distance","units","Line","startNode","endNode","options","fow","frc","lineLength","turnRestriction","bearing","reverseBearing","getLongitudeDeg","getLatitudeDeg","distanceAlong","abs","getLength","front","log","distAlong","line","lineString","along","geometry","coordinates","pt","pointToLineDistance","snapped","nearestPointOnLine","bearPoint","bearDistLoc","getGeoCoordinateAlongLine","calcBear","mapNodesLinesToID","mappedNodes","mappedLines","node","getID","OsmFowHighwayMapping","motorway","trunk","primary","secondary","tertiary","unclassified","residential","motorway_link","trunk_link","primary_link","secondary_link","tertiary_link","living_street","service","pedestrian","track","bus_guideway","excape","road","footway","bridleway","steps","path","cycleway","proposed","construction","bus_stop","crossing","elevator","emergency_access_point","give_way","mini_roundabout","motorway_junction","passing_place","rest_area","speed_camera","street_lamp","services","stop","traffic_signals","turning_circle","OsmFrcHighwayMapping","OSMIntegration","mapDataBase","relations","nodesLines","getNodesLines","setData","openLRLines","openLRNodes","osmNodes","hasOwnProperty","openLRNode","i","nd","openLRLine","getFRC","getFOW","oneWay","Array","isArray","tag","oneWayTagFound","reverseOpenLRLine","getNodesLinesDeprecatedNoOneWay","realtions","osmWay","_getTagsValues","tags","includes","Dijkstra","minLengths","followedLine","heap","Heap","b","_loop","currentNode","pop","getOutgoingLines","lfrcnp","getEndNode","maxDist","size","shortestPathLines","lastStep","unshift","getStartNode","LineDecoder","LRPs","posOffset","negOffset","candidateNodes","findCandidatesOrProjections","candidateLines","findCandidateLines","concatShortestPath","determineShortestPaths","offsets","trimAccordingToOffsets","shortestPath","candidates","findNodesCloseByCoordinate","prototype","apply","closeByLines","findLinesCloseByCoordinate","projectedPoints","location","measureAlongLine","_loop2","getReverseBearing","getBearing","candidate","lrpIndex","projected","rating","distToProjection","getDistance","rateCandidateLine","getIncomingLines","candidateNodeID","sortLines","sort","candidateLine","lrp","maxRating","startLine","endLine","distanceToNext","candidateIndexes","tries","shortestPaths","prevEndChanged","prevEndCandidateIndex","distanceBetweenLRP","distanceBetweenLRPCompensation","count","findShortestPath","calcSPforLRP","concatSP","concatenatedShortestPath","j","posProjDist","negProjDist","firstLine","lastLine","posOffsetOverflow","negOffsetOverflow","shift","OpenLRDecoder","encoded","decoderProp","rangeIncreases","k","type","decode","e","oldDist","LocationReferencePoint","islast","lon","seqNr","isLast","LRPNodeHelper","lrpLines","properties","calcProperties","pathLength","LRP","nextNode","leastFRCtillNextPoint","frcIsDefined","LineEncoder","linesToEncode","slice","checkValidityAndAdjustOffsets","adjustToValidStartEnd","checkResult","fullyCovered","lrpIndexInSP","lrpIndexInLoc","checkShortestPathCoverage","addLRPsUntilFullyCovered","concatenatedSPResult","concatenateAndValidateShortestPaths","isValid","wrongPosOffset","removeLRPatFront","distanceBetweenFirstTwo","wrongNegOffset","removeLRPatEnd","distanceBetweenLastTwo","wrongIntermediateDistance","addIntermediateLRPs","lrpLinesToLRPs","prevLineEndNode","expanded","back","hasTurnRestrictions","hasTurnRestrictionOnPath","originalStartLineId","nodeIsInValid","expand","undoExpansion","originalEndLineId","oneInOneOut","twoInTwoOut","expansionNeeded","firstIncomingStartEqFirstOutgoingEnd","secondIncomingStartEqFirstOutgoingEnd","firstIncomingStartEqSecondOutgoingEnd","secondIncomingStartEqSecondOutgoingEnd","lineToAdd","positive","originalLineId","lStartIndex","lEndIndex","spIndex","lIndex","prevCheckResult","prevShortestPath","findInvalidNodeOnLinesAfterACertainLength","shortestPathLength","nextValidNode","findNextValidNode","nextValidIndex","nextValidStartNodeIndexInLoc","lengthToLRP","spLines","invalidLRPAdded","lengthFromLRPToNextLRP","restLengthOfLines","lengthToIndex","spToValidNode","lengthOfLines","spLinesToValidNode","distanceBetweenFirstTwoLength","distanceBetweenLastTwoLength","wrongIntermediateOffset","lengthBetweenLRPs","GeoJSONRbushSearchTree","tree","geojsonrdbush","load","latDiff","toDegrees","longDiff","cos","toRadians","latUpper","latLower","longUpper","longLower","p","polygon","search","features","degrees","PI","radians","GeoJSONRbushNodeSearchTree","addNodes","isNaN","RbushLineSearchTree","addLines","MapDataBase","boundingBox","left","top","right","bottom","turnRestrictions","turnResctrictions","mapBoundingBox","nodeSearchTree","lineSearchTree","GeoJSONRbushLineSearchTree","resNodes","range","findCloseBy","_this2","resLines","distanceToPoint","lineList","getTurnRestriction","numberOfNodes","numberOfLines","nodesAdded","linesAdded","key","RoutableTilesIntegration","refToNodeId","oneway","highway","toLowerCase","area","junction","DATASET_URL","loadNodesLineStringsWegenregisterAntwerpen","reject","axios","get","then","catch","error","fetchRoutableTile","z","x","y","ldfetch","headers","accept","response","WegenregisterAntwerpenFrcWegcatMapping","hoofdweg","primaire weg I","primaire weg II","primaire weg II type 1","primaire weg II type 2","primaire weg II type 3","primaire weg II type 4","secundaire weg","secundaire weg type 1","secundaire weg type 2","secundaire weg type 3","secundaire weg type 4","lokale weg","lokale weg type 1","lokale weg type 2","lokale weg type 3","niet gekend","niet van toepassing","WegenregisterAntwerpenFowMorfMapping","autosnelweg","weg met gescheiden rijbanen die geen autosnelweg is","weg bestaande uit één rijbaan","rotonde","speciale verkeerssituatie","verkeersplein","op- of afrit, behorende tot een nietgelijkgrondse verbinding","op- of afrit, behorende tot een gelijkgrondse verbinding","parallelweg","ventweg","in- of uitrit van een parking","in- of uitrit van een dienst","voetgangerszone","wandel- of fietsweg, niet toegankelijk voor andere voertuigen","tramweg, niet toegankelijk voor andere voertuigen","dienstweg","aardeweg","veer","WegenregisterAntwerpenIntegration","directionIsUndef","RIJRICHTING_AUTO","prevLat","prevLong","GeoJsonIntegration","map","LinesDirectlyToLRPs","encLines","getTileXYForLocation","latitude","longitude","floor","pow","_long2tile","tan","_lat2tile","tile2boundingBox","north","_tile2lat","south","_tile2long","n","atan","exp","GeoJSONRBushPolygonSearchTree","featureCollection","geojsonrbush","addPolygons","findInRange","Catalog","searchTree","amountOfDatasets","sets","_createFeaturesForGeoSpatialDataSets","currentPage","nextPage","lastPage","set","dataSets","geojson","hasValidKeyword","distribution","distributions","namedNode","n3","DataFactory","parseAndStoreQuads","_doc","parser","Parser","store","Store","parse","quad","prefixes","addQuad","getDataSets","_x","_getDataSets","_callee","_store","regenerator_default","wrap","_context","prev","next","getQuads","abrupt","getDistributions","_x2","_getDistributions","_callee2","distributionsData","_context3","mark","_context2","t0","keys","t1","done","delegateYield","getLocationIDtoDataSet","_x3","_getLocationIDtoDataSet","_callee3","locationIDtoDataSet","_context4","getGeometries","_x4","_getGeometries","_callee4","geometries","_context5","JSON","getKeywords","_x5","_getKeywords","_callee5","keyWords","_context6","getPagingInfo","_x6","_getPagingInfo","_callee6","paging","_context7","getDataSetsFromTriples","keywords","triple","pagingInfo","_args","all","d","fetchCatalog","catalogUrl","download","_uri","linestringToLatLng","linestring","result","numbers","number","parseFloat","calcDistance","lat1","long1","lat2","long2","getLaneDefs","_getLaneDefs","lanes","encodingStratEnum","OpenLrEncode","LinesToLRPs","lineVisualisationEnum","RawLineStrings","MappedLineStrings","catalogEnum","vodap","verkeerslichtdata_catalog_ttl","MainDemo","_React$Component","tileXY","encodingStrat","lineVisualisation","catalog","tiles","catalogInitialized","initCatalog","dataBaseInitialized","setLocation","mappedDataSets","resetMap","handleGeoJsonClick","handleEncodingStratSelect","handleLineStringVisualisationSelect","handleInternalPrecisionSelect","handleCatalogSelect","inherits","createClass","performance","now","c","t3","addCatalogPage","t4","fetchNextPage","uriPrefix","t2","r","logging","r2","_getDataSetsFromStore","getDataSetsFromStore","_this3","nodesAndLines","addData","latLong","_this4","promises","ix","iy","addRoutableTileToMapDataBase","datasets","getDataSetsInRange","getDatasetCount","dataset","addGeoJson","react","GeoJSON","_this$location","_this$state","TileView_TileView","name","onChange","event","_this5","originalEvent","view","L","DomEvent","stopPropagation","datasetFeature","sourceTarget","feature","doc","_getTrafficLightData","parsed","_toLRPs","en","decoded","lineData","createLineStringsOpenLrForLane","lane","_createRawLineStrings","target","startArrive","laneDefs","signalGroups","signalGroup","departureLanes","arrivalLanes","connection","lanesForSignalGroup","newLanes","departureLane","arrivalLane","depEndToArrStart","depEndToArrEnd","depStartToArrStart","depStartToArrEnd","reverse","getLanesAsArrayInCorrectDirection","Polyline","positions","Popup","l","_mapNodesLinesToID","encode","lineStrings","color","firstOffsetCoord","lastOffsetCoord","Circle","radius","inputDataEnum","RoutableTiles","OpenStreetMap","Wegenregister_Antwerpen","Geojson_kruispunt_tropisch_instituut","OpenLrDemo","dataSource","addMarker","reset","findMarkersOsm","findMarkersRoutableTiles","findMarkers","handleDataSourceSelect","addDataBases","showLanesAntwerpenTest","osmDataBase","routableTilesDataBase","wegenregisterDataBase","geojsonKruispuntDataBase","dataBasesInitialized","findMarkersWegenregisterAntwerpen","findMarkersGeojsonKruispunt","createLineStringsOpenLr","alert","initMapDataBase","createMarker","_this6","promise","addOpenStreetMapTileToMapDataBase","_this7","_this8","xml","validate","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","trimValues","json","osm","way","relation","getMappedElements","elements","highwayData","createPolyline","_this9","database","Marker","seq","NavBar","handleItemClick","_ref","activeItem","Menu","Item","as","Link","active","App","react_router_dom","components_NavBar","react_router","component","Boolean","window","hostname","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.04256c66.chunk.js","sourcesContent":["import React from 'react';\r\nimport {Map, TileLayer} from 'react-leaflet';\r\n\r\nexport default class TileView extends React.Component {\r\n    constructor(props) {\r\n        super();\r\n        this.zoom = props.zoom;\r\n        this.state = {\r\n            data: props.data,\r\n            lat: props.lat,\r\n            lng: props.lng\r\n        };\r\n        this.handleMouseClick = this.handleMouseClick.bind(this);\r\n    }\r\n\r\n    componentWillReceiveProps(newProps) {\r\n        this.setState({data: newProps.data, lat: newProps.lat, lng: newProps.lng})\r\n    }\r\n\r\n    handleMouseClick(ev){\r\n        if(this.props.onMouseClick !== undefined){\r\n            this.props.onMouseClick(ev.latlng);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const position = [this.state.lat, this.state.lng];\r\n        const zoom = this.zoom;\r\n        const {data} = this.state;\r\n        return (\r\n            <Map\r\n                style = {{height: '850px'}}\r\n                center = {position}\r\n                zoom = {zoom}\r\n                onClick = {this.handleMouseClick}\r\n            >\r\n                <\r\n                    TileLayer\r\n                    attribution = '&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n                    url = \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\r\n                />\r\n                {data}\r\n            </Map>\r\n        )\r\n    }\r\n}","import parser from 'fast-xml-parser';\r\n\r\n/*\r\nGaat er van uit dat de eerst de lat en long van node wordt vermeld in een triple, dan de node zijn ID binnen de tile\r\nen dan vervolgens de Ways die verwijzen naar deze interne ID's zodat een lijst van alle nodes en lines opstellen in 1 run kan gebeuren.\r\n */\r\nexport function getRoutableTilesNodesAndLines(triples){\r\n    return new Promise((resolve)=>{\r\n        let nodes = {};\r\n        let ways = {};\r\n\r\n        let prevInternalNodeID = undefined;\r\n        let currentWayElement = undefined;\r\n        triples.forEach(function(element){\r\n            if(element.subject && element.predicate && element.object){\r\n                let foundNodeInObject = /^http:\\/\\/www\\.openstreetmap\\.org\\/node\\/\\d*$/g.exec(element.object.value);\r\n                let foundNodeInSubject = /^http:\\/\\/www\\.openstreetmap\\.org\\/node\\/\\d*$/g.exec(element.subject.value);\r\n                // let foundWayInObject = /^http:\\/\\/www\\.openstreetmap\\.org\\/way\\/\\d*$/g.exec(element.object.value);\r\n                let foundWayInSubject = /^http:\\/\\/www\\.openstreetmap\\.org\\/way\\/\\d*$/g.exec(element.subject.value);\r\n\r\n                // if(element.subject.value === \"http://www.openstreetmap.org/node/1085435860\"){\r\n                //     console.log(element);\r\n                // }\r\n                if(foundNodeInObject){\r\n                  if(element.predicate.value === \"http://www.w3.org/1999/02/22-rdf-syntax-ns#first\"){\r\n                      if(nodes[element.object.value] === undefined){\r\n                          nodes[element.object.value] = {id: element.object.value, ref: []}\r\n                      }\r\n                      nodes[element.object.value].ref.push(element.subject.value);\r\n                  }\r\n                  else{\r\n                      console.warn(element);\r\n                  }\r\n                }\r\n                else if(foundNodeInSubject){\r\n                    // console.log(element);\r\n                    if(element.predicate.value === \"http://www.w3.org/2003/01/geo/wgs84_pos#lat\"){\r\n                        if(nodes[element.subject.value] === undefined){\r\n                            nodes[element.subject.value] = {id: element.subject.value, ref: []}\r\n                        }\r\n                        nodes[element.subject.value].lat = Number(element.object.value);\r\n                    }\r\n                    else if(element.predicate.value === \"http://www.w3.org/2003/01/geo/wgs84_pos#long\"){\r\n                        if(nodes[element.subject.value] === undefined){\r\n                            nodes[element.subject.value] = {id: element.subject.value, ref: []}\r\n                        }\r\n                        nodes[element.subject.value].long = Number(element.object.value);\r\n                    }\r\n                }\r\n                // else if(foundWayInObject){\r\n                //     // console.log(element);\r\n                // }\r\n                else if(foundWayInSubject){\r\n                    if(element.predicate.value === \"https://w3id.org/openstreetmap/terms#hasNodes\") {\r\n                        if (ways[element.subject.value] === undefined) {\r\n                            ways[element.subject.value] = {\r\n                                nodes: [],\r\n                                id: element.subject.value\r\n                            };\r\n                        }\r\n                        ways[element.subject.value].nodes.push(element.object.value.toString());\r\n                        currentWayElement = element.subject.value;\r\n                        prevInternalNodeID = element.object.value;\r\n                    }\r\n                    else {\r\n                        let match = (/^https:\\/\\/w3id.org\\/openstreetmap\\/terms#(.*)$/g.exec(element.predicate.value));\r\n                        if(match){\r\n                            if (ways[element.subject.value] === undefined) {\r\n                                ways[element.subject.value] = {\r\n                                    nodes: [],\r\n                                    id: element.subject.value\r\n                                };\r\n                            }\r\n                            if(match[1] === \"hasTag\"){ // compatibility code with new routable tiles standard 30/05/2019, will definitely change in future\r\n                                if(element.object.value.indexOf(\"=\") !== -1){\r\n                                    let res = element.object.value.split(\"=\");\r\n                                    if(res[0] === \"area\" || res[0] === \"junction\"){\r\n                                        ways[element.subject.value][res[0]] = res[1];\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                ways[element.subject.value][match[1]] = element.object.value;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else if(element.predicate.value === \"http://www.w3.org/1999/02/22-rdf-syntax-ns#rest\"){\r\n                    if(element.subject.value === prevInternalNodeID && element.object.value !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#nil\"){\r\n                        if(currentWayElement === undefined){\r\n                            throw Error(\"Found a node for an undefined way.\");\r\n                        }\r\n                        else{\r\n                            ways[currentWayElement].nodes.push(element.object.value);\r\n                            prevInternalNodeID = element.object.value;\r\n                        }\r\n                    }\r\n                    else{\r\n                        currentWayElement = undefined;\r\n                        prevInternalNodeID = undefined;\r\n                    }\r\n                }\r\n                // else{\r\n                //     console.log(element);\r\n                // }\r\n            }\r\n        });\r\n\r\n        resolve({nodes: nodes, lines: ways});\r\n    });\r\n}\r\n\r\nexport function parseToJson(xml){\r\n    return new Promise(((resolve,reject) => {\r\n        let options = {\r\n            // attributeNamePrefix : \"@_\",\r\n            // attrNodeName: \"attr\", //default is 'false'\r\n            // textNodeName : \"#text\",\r\n            ignoreAttributes : false,\r\n            ignoreNameSpace : false,\r\n            allowBooleanAttributes : true,\r\n            parseNodeValue : true,\r\n            parseAttributeValue : true,\r\n            trimValues: true,\r\n            // cdataTagName: \"__cdata\", //default is 'false'\r\n            // cdataPositionChar: \"\\\\c\",\r\n            // localeRange: \"\", //To support non english character in tag/attribute values.\r\n            // parseTrueNumberOnly: false,\r\n            // attrValueProcessor: a => he.decode(a, {isAttributeValue: true}),//default is a=>a\r\n            // tagValueProcessor : a => he.decode(a) //default is a=>a\r\n        };\r\n\r\n        if(parser.validate(xml) === true)\r\n            resolve(parser.parse(xml,options));\r\n        else{\r\n            reject(\"could not parse xml\")\r\n        }\r\n    }));\r\n}\r\n\r\n//zou eigenlijk al bij parsing moeten gebeuren\r\nexport function getMappedElements(json){\r\n    return new Promise((resolve)=>{\r\n        let nodes = {};\r\n        let ways = {};\r\n        let relations = {};\r\n        json.osm.node.forEach(function(node){\r\n            nodes[node[\"@_id\"]] = node;\r\n        });\r\n        json.osm.way.forEach(function (way) {\r\n            ways[way[\"@_id\"]] = way;\r\n        });\r\n        json.osm.relation.forEach(function (relation) {\r\n            relations[relation[\"@_id\"]] = relation;\r\n        });\r\n         resolve ({nodes: nodes, ways: ways, relations: relations});\r\n    });\r\n}\r\n\r\nexport function filterHighwayData(data){\r\n    return new Promise((resolve => {\r\n        let ways = {};\r\n        for(let key in data.ways){\r\n            if(data.ways.hasOwnProperty(key) && data.ways[key].tag !== undefined){\r\n                if(Array.isArray(data.ways[key].tag)){\r\n                    data.ways[key].tag.forEach(function (tag) {\r\n                        if(tag[\"@_k\"] === \"highway\"){\r\n                            ways[key] = data.ways[key];\r\n                        }\r\n                    });\r\n                }\r\n                else if(data.ways[key].tag[\"@_k\"] !== undefined && data.ways[key].tag[\"@_k\"] === \"highway\"){\r\n                    ways[key] = data.ways[key];\r\n                }\r\n            }\r\n        }\r\n        resolve({nodes: data.nodes, ways: ways, relations: data.relations});\r\n    }));\r\n}","export let fowEnum = Object.freeze({\r\n    \"UNDEFINED\": 0, // The physical road type is unknown.\r\n    \"MOTORWAY\": 1, // A Motorway is defined as a road permitted for motorized vehicles only in combination with a prescribed minimum speed.\r\n    \"MULTIPLE_CARRIAGEWAY\": 2, // A multiple carriageway is defined as a road with physically separated carriageways regardless of the number of lanes.\r\n    \"SINGLE_CARRIAGEWAY\": 3, // All roads without separate carriageways are considered as roads with a single carriageway.\r\n    \"ROUNDABOUT\": 4, // A Roundabout is a road which forms a ring on which traffic travelling in only one direction is allowed.\r\n    \"TRAFFICSQUARE\": 5, // A Traffic Square is an open area (partly) enclosed by roads which is used for non-traffic purposes and which is not a Roundabout.\r\n    \"SLIPROAD\": 6, // A Slip Road is a road especially designed to enter or leave a line.\r\n    \"OTHER\": 7 // The physical road type is known but does not fit into one of the other categories.\r\n});\r\n\r\nexport let frcEnum = Object.freeze({\r\n    \"FRC_0\": 0, // Main road.\r\n    \"FRC_1\": 1, // First class road.\r\n    \"FRC_2\": 2, // Second class road.\r\n    \"FRC_3\": 3, // Third class road.\r\n    \"FRC_4\": 4, // Forth class road.\r\n    \"FRC_5\": 5, // Fifth class road.\r\n    \"FRC_6\": 6, // Sixth class road.\r\n    \"FRC_7\": 7 // Other class road.\r\n});\r\n\r\nexport let locationTypeEnum = Object.freeze({\r\n    \"UNKNOWN\": 0,\r\n    \"LINE_LOCATION\": 1,\r\n    \"GEO_COORDINATES\": 2,\r\n    \"POINT_ALONG_LINE\": 3,\r\n    \"POI_WITH_ACCESS_POINT\": 4,\r\n    \"CIRCLE\": 5,\r\n    \"POLYGON\": 6,\r\n    \"CLOSED_LINE\": 7,\r\n    \"RECTANGLE\": 8,\r\n    \"GRID\": 9\r\n});\r\n\r\nexport let internalPrecisionEnum = Object.freeze(({\r\n    \"METER\": 1,\r\n    \"CENTIMETER\": 100\r\n}));\r\n","import {internalPrecisionEnum} from \"../map/Enum\";\r\n\r\nlet decoderProperties = {\r\n    dist: 5,    //maximum distance (in meter) of a candidate node to a LRP\r\n    bearDiff: 60, //maximum difference (in degrees) between the bearing of a candidate node and that of a LRP\r\n    frcDiff: 3, //maximum difference between the FRC of a candidate node and that of a LRP\r\n    lfrcnpDiff: 3, //maximum difference between the lowest FRC until next point of a candidate node and that of a LRP\r\n    distanceToNextDiff: 40, //maximum difference (in meter) between the found distance between 2 LRPs and the given distanceToNext of the first LRP\r\n    alwaysUseProjections: false,\r\n    useFrcFow: true,\r\n    distMultiplier: 40,\r\n    frcMultiplier: 35,\r\n    fowMultiplier: 40,\r\n    bearMultiplier: 30,\r\n    maxSPSearchRetries: 200,\r\n    maxDecodeRetries: 2,\r\n    distMultiplierForRetry: 2\r\n};\r\n\r\nlet configProperties = {\r\n    bearDist: 20, // in meter!!\r\n    internalPrecision: internalPrecisionEnum.CENTIMETER\r\n};\r\n\r\nexport {decoderProperties,configProperties};","import distance from '@turf/distance';\r\nimport {point} from '@turf/helpers'\r\nimport {configProperties} from \"../coder/CoderSettings\";\r\nimport {internalPrecisionEnum} from \"./Enum\";\r\n\r\nexport default class Node{\r\n    constructor(id=0,lat=0,long=0,incomingLines=[],outgoingLines=[]){\r\n        this.id = id;\r\n        this.lat = lat;\r\n        this.long = long;\r\n        this.incomingLines = incomingLines;\r\n        this.outgoingLines = outgoingLines;\r\n        this.setLines(incomingLines,outgoingLines);\r\n        this.internalPrecision = configProperties.internalPrecision;\r\n    }\r\n\r\n    setLines(incomingLines,outgoingLines){\r\n        this.incomingLines = incomingLines;\r\n        this.outgoingLines = outgoingLines;\r\n    }\r\n\r\n    getLatitudeDeg(){\r\n        return this.lat;\r\n    }\r\n\r\n    getLongitudeDeg(){\r\n        return this.long;\r\n    }\r\n\r\n    getOutgoingLines(){\r\n        return this.outgoingLines;\r\n    }\r\n\r\n    getIncomingLines(){\r\n        return this.incomingLines;\r\n    }\r\n\r\n    getID(){\r\n        return this.id;\r\n    }\r\n\r\n    getDistance(lat,long){\r\n        let from = point([\r\n            this.long,\r\n            this.lat\r\n        ]);\r\n        let to = point([\r\n            long,\r\n            lat\r\n        ]);\r\n        if(this.internalPrecision === internalPrecisionEnum.CENTIMETER){\r\n            return Math.round(distance(from,to,{units: \"centimeters\"}));\r\n        }\r\n        else{\r\n            return Math.round(distance(from,to,{units: \"meters\"}));\r\n        }\r\n    }\r\n}","import pointToLineDistance from '@turf/point-to-line-distance';\r\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\r\nimport along from '@turf/along';\r\nimport {point,lineString} from '@turf/helpers'\r\nimport distance from \"@turf/distance/index\";\r\nimport bearing from '@turf/bearing'\r\nimport {fowEnum, frcEnum, internalPrecisionEnum} from \"./Enum\";\r\nimport {configProperties} from \"../coder/CoderSettings\";\r\n\r\n\r\nexport default class Line {\r\n    constructor(id,startNode,endNode,options){\r\n        this.startNode = startNode;\r\n        this.endNode = endNode;\r\n        this.id = id;\r\n        this.fow = fowEnum.UNDEFINED;\r\n        this.frc = frcEnum.FRC_7;\r\n        this.lineLength = undefined;\r\n        this.turnRestriction = undefined;\r\n        this.bearing = undefined;\r\n        this.reverseBearing = undefined;\r\n        startNode.outgoingLines.push(this);\r\n        endNode.incomingLines.push(this);\r\n        this.internalPrecision = configProperties.internalPrecision;\r\n    }\r\n\r\n    getStartNode(){\r\n        return this.startNode;\r\n    }\r\n\r\n    getEndNode(){\r\n        return this.endNode;\r\n    }\r\n\r\n    getFOW(){\r\n        return this.fow;\r\n    }\r\n\r\n    getFRC(){\r\n        return this.frc;\r\n    }\r\n\r\n    getLength(){\r\n        if(this.lineLength === undefined && this.startNode !== undefined && this.endNode !== undefined){\r\n            let from = point([\r\n                this.startNode.getLongitudeDeg(),\r\n                this.startNode.getLatitudeDeg()\r\n            ]);\r\n            let to = point([\r\n                this.endNode.getLongitudeDeg(),\r\n                this.endNode.getLatitudeDeg()\r\n            ]);\r\n            if(this.internalPrecision === internalPrecisionEnum.CENTIMETER){\r\n                this.lineLength = Math.round(distance(from,to,{units: \"centimeters\"})); //work with integer values in centimeter\r\n            }\r\n            else{\r\n                this.lineLength = Math.round(distance(from,to,{units: \"meters\"})); //work with integer values in meter\r\n            }\r\n            if(this.lineLength === 0){\r\n                this.lineLength = 1;    //but minimum value should be 1\r\n            }\r\n        }\r\n        return this.lineLength;\r\n    }\r\n\r\n    getID(){\r\n        return this.id;\r\n    }\r\n\r\n    getTurnRestriction(){\r\n        return this.turnRestriction;\r\n    }\r\n\r\n    getGeoCoordinateAlongLine(distanceAlong){\r\n        if(Math.abs(distanceAlong)>this.getLength()){\r\n            let front = distanceAlong >= 0;\r\n            console.log(\"Line shorter than \"+distanceAlong+\". The latitude and longitude of \"+(front?\"startNode\":\"endNode\")+\" are returned\");\r\n            if(front){\r\n                return {\r\n                    lat: this.endNode.getLatitudeDeg(),\r\n                    long: this.endNode.getLongitudeDeg()\r\n                };\r\n            }\r\n            else{\r\n                return {\r\n                    lat: this.startNode.getLatitudeDeg(),\r\n                    long: this.startNode.getLongitudeDeg()\r\n                };\r\n            }\r\n        }\r\n        let line = lineString([\r\n            [this.startNode.getLongitudeDeg(),this.startNode.getLatitudeDeg()],\r\n            [this.endNode.getLongitudeDeg(),this.endNode.getLatitudeDeg()]\r\n        ]);\r\n        let distAlong;\r\n        if(this.internalPrecision === internalPrecisionEnum.CENTIMETER){\r\n            distAlong = along(line,distanceAlong,{units: 'centimeters'});\r\n        }\r\n        else{\r\n            distAlong = along(line,distanceAlong,{units: 'meters'});\r\n        }\r\n\r\n        //return distAlong.geometry;\r\n        return {\r\n            lat: distAlong.geometry.coordinates[1],\r\n            long: distAlong.geometry.coordinates[0]\r\n        }\r\n    }\r\n\r\n    distanceToPoint(lat,long){\r\n        let pt = point([long,lat]);\r\n        let line = lineString(\r\n            [[this.startNode.getLongitudeDeg(),this.startNode.getLatitudeDeg()],\r\n            [this.endNode.getLongitudeDeg(),this.endNode.getLatitudeDeg()]]\r\n        );\r\n        if(this.internalPrecision === internalPrecisionEnum.CENTIMETER){\r\n            return Math.round(pointToLineDistance(pt,line, {units: 'centimeters'}));\r\n        }\r\n        else{\r\n            return Math.round(pointToLineDistance(pt,line, {units: 'meters'}));\r\n        }\r\n    }\r\n\r\n    measureAlongLine(lat,long){\r\n        let pt = point([long,lat]);\r\n        let line = lineString([\r\n            [this.startNode.getLongitudeDeg(),this.startNode.getLatitudeDeg()],\r\n            [this.endNode.getLongitudeDeg(),this.endNode.getLatitudeDeg()]\r\n        ]);\r\n        let snapped = nearestPointOnLine(line,pt,{units: 'meters'});\r\n        return {\r\n            lat: snapped.geometry.coordinates[1],\r\n            long: snapped.geometry.coordinates[0]\r\n        }\r\n    }\r\n\r\n    getBearing(){\r\n        if(this.bearing === undefined){\r\n            let startNode = point([this.startNode.getLongitudeDeg(),this.startNode.getLatitudeDeg()]);\r\n            let bearPoint;\r\n            if(this.getLength() <= configProperties.bearDist*configProperties.internalPrecision){\r\n                bearPoint = point([this.endNode.getLongitudeDeg(),this.endNode.getLatitudeDeg()]);\r\n            }\r\n            else{\r\n                let bearDistLoc = this.getGeoCoordinateAlongLine(configProperties.bearDist*configProperties.internalPrecision);\r\n                bearPoint = point([bearDistLoc.long,bearDistLoc.lat]);\r\n            }\r\n\r\n            let calcBear = bearing(startNode, bearPoint);\r\n            // bear is always positive, counterclockwise\r\n            calcBear = (calcBear+360.0)%360.0;\r\n            this.bearing = Math.round(calcBear);\r\n        }\r\n        return this.bearing;\r\n    }\r\n\r\n    getReverseBearing(){\r\n        if(this.reverseBearing === undefined){\r\n            let startNode = point([this.endNode.getLongitudeDeg(),this.endNode.getLatitudeDeg()]);\r\n            let bearPoint;\r\n            if(this.getLength() <= configProperties.bearDist*configProperties.internalPrecision){\r\n                bearPoint = point([this.startNode.getLongitudeDeg(),this.startNode.getLatitudeDeg()]);\r\n            }\r\n            else{\r\n                let bearDistLoc = this.getGeoCoordinateAlongLine(this.getLength()-(configProperties.bearDist*configProperties.internalPrecision));\r\n                bearPoint = point([bearDistLoc.long,bearDistLoc.lat]);\r\n            }\r\n\r\n            let calcBear = bearing(startNode, bearPoint);\r\n            // bear is always positive, counterclockwise\r\n            calcBear = (calcBear+360.0)%360.0;\r\n            this.reverseBearing = Math.round(calcBear);\r\n        }\r\n        return this.reverseBearing;\r\n    }\r\n}","import Node from \"../map/Node\";\r\nimport Location from \"../coder/Location\";\r\nimport Line from \"../map/Line\";\r\nimport {locationTypeEnum} from \"../map/Enum\";\r\n\r\nexport function generateStraightLaneTestData(){\r\n    let lines = [];\r\n    let nodes = [];\r\n    let node1 = new Node(1,51.2120579,4.3974671);\r\n    let node2 = new Node(2,51.2118214,4.3991321);\r\n    let node3 = new Node(3,51.2120361,4.3974671);\r\n    let node4 = new Node(4,51.2120058,4.3976971);\r\n    let node5 = new Node(5,51.2120184,4.3977501);\r\n    //todo: line parameters (length, frc, ...)\r\n    let line1 = new Line(1,node1,node2);\r\n    let line2 = new Line(2,node3,node4);\r\n    let line3 = new Line(3,node4,node5);\r\n    node1.setLines([],[line1]);\r\n    node2.setLines([line1],[]);\r\n    node3.setLines([],[line2]);\r\n    node4.setLines([line2],[line3]);\r\n    node5.setLines([line3],[]);\r\n    nodes.push(node1,node2,node3,node4,node5);\r\n    lines.push(line1,line2,line3);\r\n\r\n    let singleLineLane = new Location(locationTypeEnum.LINE_LOCATION,1);\r\n    singleLineLane.locationLines = [line1];\r\n\r\n    let doubleLineLane = new Location(locationTypeEnum.LINE_LOCATION,2);\r\n    doubleLineLane.locationLines = [line2,line3];\r\n\r\n    let unconnectedLane = new Location(locationTypeEnum.LINE_LOCATION,3);\r\n    unconnectedLane.locationLines = [line1,line3];\r\n\r\n    let invalidStartNodeLane = new Location(locationTypeEnum.LINE_LOCATION,4);\r\n    invalidStartNodeLane.locationLines=[line3];\r\n\r\n    let invalidEndNodeLane = new Location(locationTypeEnum.LINE_LOCATION,5);\r\n    invalidEndNodeLane.locationLines=[line2];\r\n\r\n    return {\r\n        lines: lines,\r\n        nodes: nodes,\r\n        singleLineLane: singleLineLane,\r\n        doubleLineLane: doubleLineLane,\r\n        unconnectedLane: unconnectedLane,\r\n        invalidStartNodeLane: invalidStartNodeLane,\r\n        invalidEndNodeLane: invalidEndNodeLane\r\n    }\r\n}\r\n\r\nexport function mapNodesLinesToID(nodes,lines){\r\n    let mappedNodes = {};\r\n    let mappedLines = {};\r\n\r\n    nodes.forEach(function (node) {\r\n        if(node !== undefined)\r\n            mappedNodes[node.getID()] = node;\r\n    });\r\n\r\n    lines.forEach(function (line) {\r\n        if(line !== undefined)\r\n            mappedLines[line.getID()] = line;\r\n    });\r\n\r\n    return {\r\n        nodes: mappedNodes,\r\n        lines: mappedLines\r\n    }\r\n}\r\n\r\nexport function generateTestNetwork(){\r\n    let nodeA = new Node(1,-8,-3);\r\n    let nodeB = new Node(2,-6,5);\r\n    let nodeC = new Node(3,-3,3);\r\n    let nodeD = new Node(4,-1,1);\r\n    let nodeE = new Node(5,-1,-2);\r\n    let nodeF = new Node(6,0,5);\r\n    let nodeG = new Node(7,3,5);\r\n    let nodeH = new Node(8,3,2);\r\n    let nodeI = new Node(9,7,5);\r\n    let nodeJ = new Node(10,7,-1);\r\n\r\n    let line1 = new Line(1,nodeA,nodeB);\r\n    let line14 = new Line(14,nodeB,nodeA);\r\n    let line2 = new Line(2,nodeB,nodeF);\r\n    let line15 = new Line(15,nodeF,nodeB);\r\n    let line3 = new Line(3,nodeF,nodeG);\r\n    let line16 = new Line(16,nodeG,nodeF);\r\n    let line4 = new Line(4,nodeG,nodeI);\r\n    let line17 = new Line(17,nodeI,nodeG);\r\n    let line5 = new Line(5,nodeC,nodeF);\r\n    let line18 = new Line(18,nodeF,nodeC);\r\n    let line6 = new Line(6,nodeD,nodeG);\r\n    let line19 = new Line(19,nodeG,nodeD);\r\n    let line7 = new Line(7,nodeH,nodeG);\r\n    let line20 = new Line(20,nodeG,nodeH);\r\n    let line8 = new Line(8,nodeH,nodeI);\r\n    let line21 = new Line(21,nodeI,nodeH);\r\n    let line9 = new Line(9,nodeI,nodeJ);\r\n    let line22 = new Line(22,nodeJ,nodeI);\r\n    let line10 = new Line(10,nodeC,nodeD);\r\n    let line23 = new Line(23,nodeD,nodeC);\r\n    let line11 = new Line(11,nodeD,nodeH);\r\n    let line24 = new Line(24,nodeH,nodeD);\r\n    let line12 = new Line(12,nodeE,nodeH);\r\n    let line25 = new Line(25,nodeH,nodeE);\r\n    let line13 = new Line(13,nodeH,nodeJ);\r\n    let line26 = new Line(26,nodeJ,nodeH);\r\n\r\n    return {\r\n        nodes: [nodeA,nodeB,nodeC,nodeD,nodeE,nodeF,nodeG,nodeH,nodeI,nodeJ],\r\n        lines: [undefined,line1,line2,line3,line4,line5,line6,line7,line8,line9,line10,line11,line12,line13,line14,line15,line16,line17,line18,line19,line20,line21,line22,line23,line24,line25,line26]\r\n    }\r\n}\r\n\r\nexport function generateRealisticLengthTestNetwork(){\r\n    let nodeA = new Node(1,-8*0.001+51,-3*0.001+4);\r\n    let nodeB = new Node(2,-6*0.001+51,5*0.001+4);\r\n    let nodeC = new Node(3,-3*0.001+51,3*0.001+4);\r\n    let nodeD = new Node(4,-1*0.001+51,1*0.001+4);\r\n    let nodeE = new Node(5,-1*0.001+51,-2*0.001+4);\r\n    let nodeF = new Node(6,0*0.001+51,5*0.001+4);\r\n    let nodeG = new Node(7,3*0.001+51,5*0.001+4);\r\n    let nodeH = new Node(8,3*0.001+51,2*0.001+4);\r\n    let nodeI = new Node(9,7*0.001+51,5*0.001+4);\r\n    let nodeJ = new Node(10,7*0.001+51,-1*0.001+4);\r\n\r\n    let line1 = new Line(1,nodeA,nodeB);\r\n    let line14 = new Line(14,nodeB,nodeA);\r\n    let line2 = new Line(2,nodeB,nodeF);\r\n    let line15 = new Line(15,nodeF,nodeB);\r\n    let line3 = new Line(3,nodeF,nodeG);\r\n    let line16 = new Line(16,nodeG,nodeF);\r\n    let line4 = new Line(4,nodeG,nodeI);\r\n    let line17 = new Line(17,nodeI,nodeG);\r\n    let line5 = new Line(5,nodeC,nodeF);\r\n    let line18 = new Line(18,nodeF,nodeC);\r\n    let line6 = new Line(6,nodeD,nodeG);\r\n    let line19 = new Line(19,nodeG,nodeD);\r\n    let line7 = new Line(7,nodeH,nodeG);\r\n    let line20 = new Line(20,nodeG,nodeH);\r\n    let line8 = new Line(8,nodeH,nodeI);\r\n    let line21 = new Line(21,nodeI,nodeH);\r\n    let line9 = new Line(9,nodeI,nodeJ);\r\n    let line22 = new Line(22,nodeJ,nodeI);\r\n    let line10 = new Line(10,nodeC,nodeD);\r\n    let line23 = new Line(23,nodeD,nodeC);\r\n    let line11 = new Line(11,nodeD,nodeH);\r\n    let line24 = new Line(24,nodeH,nodeD);\r\n    let line12 = new Line(12,nodeE,nodeH);\r\n    let line25 = new Line(25,nodeH,nodeE);\r\n    let line13 = new Line(13,nodeH,nodeJ);\r\n    let line26 = new Line(26,nodeJ,nodeH);\r\n\r\n    return {\r\n        nodes: [nodeA,nodeB,nodeC,nodeD,nodeE,nodeF,nodeG,nodeH,nodeI,nodeJ],\r\n        lines: [undefined,line1,line2,line3,line4,line5,line6,line7,line8,line9,line10,line11,line12,line13,line14,line15,line16,line17,line18,line19,line20,line21,line22,line23,line24,line25,line26]\r\n    }\r\n}\r\n\r\nexport function loadRTtestNetworkWithLoop(){\r\n    let n1 = new Node(\"http://www.openstreetmap.org/node/4691959557\",51.2126651,4.4066541);\r\n    let n2 = new Node(\"http://www.openstreetmap.org/node/5607822120\",51.2126422,4.4066453);\r\n    let n3 = new Node(\"http://www.openstreetmap.org/node/5607832955\",51.2126153,4.4067580);\r\n    let n4 = new Node(\"http://www.openstreetmap.org/node/5607832954\",51.2125941,4.4068391);\r\n    let n5 = new Node(\"http://www.openstreetmap.org/node/5607832950\",51.2125183,4.4070575);\r\n    let n6 = new Node(\"http://www.openstreetmap.org/node/5607832953\",51.2124908,4.4071645);\r\n    let n7 = new Node(\"http://www.openstreetmap.org/node/5607822421\",51.2124336,4.4074395);\r\n    let n8 = new Node(\"http://www.openstreetmap.org/node/5607822443\",51.2124724,4.4074550);\r\n    let n9 = new Node(\"http://www.openstreetmap.org/node/5607832951\",51.2125418,4.4073929);\r\n    let n10 = new Node(\"http://www.openstreetmap.org/node/5607822427\",51.2126749,4.4073613);\r\n    let n11 = new Node(\"http://www.openstreetmap.org/node/5607822435\",51.2128848,4.4073296);\r\n    let n12 = new Node(\"http://www.openstreetmap.org/node/4691959567\",51.2128858,4.4082370);\r\n    let n13 = new Node(\"http://www.openstreetmap.org/node/4691959568\",51.2128258,4.4071835);\r\n    let n14 = new Node(\"http://www.openstreetmap.org/node/4691959569\",51.2127736,4.4071085);\r\n    let n15 = new Node(\"http://www.openstreetmap.org/node/4691959570\",51.2127100,4.4069567);\r\n\r\n    let l1 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/4691959557\",n1,n2);\r\n    let l2 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607822120\",n2,n3);\r\n    let l3 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607832955\",n3,n4);\r\n    let l4 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607832954\",n4,n5);\r\n    let l5 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607832950\",n5,n6);\r\n    let l6 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607832953\",n6,n7);\r\n    let l7 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607822421\",n7,n8);\r\n    let l8 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607822443\",n8,n9);\r\n    let l9 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607832951\",n9,n10);\r\n    let l10 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607822427\",n10,n11);\r\n    let l11 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/5607822435\",n11,n12);\r\n    let l12 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/4691959567\",n12,n13);\r\n    let l13 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/4691959568\",n13,n14);\r\n    let l14 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/4691959569\",n14,n15);\r\n    let l15 = new Line(\"http://www.openstreetmap.org/way/150668711_http://www.openstreetmap.org/node/4691959570\",n15,n1);\r\n\r\n    return {\r\n        nodes: [n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15],\r\n        lines: [l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15]\r\n    }\r\n}","import {fowEnum} from \"../../OpenLR/map/Enum\";\r\n\r\n//based on https://wiki.openstreetmap.org/wiki/Key:highway\r\n//and https://wiki.openstreetmap.org/wiki/NL:The_Netherlands_roads_tagging\r\nexport let OsmFowHighwayMapping = {\r\n    \"motorway\": fowEnum.MULTIPLE_CARRIAGEWAY,\r\n    \"trunk\": fowEnum.MOTORWAY,\r\n    \"primary\": fowEnum.SINGLE_CARRIAGEWAY,\r\n    \"secondary\": fowEnum.SINGLE_CARRIAGEWAY,\r\n    \"tertiary\": fowEnum.SINGLE_CARRIAGEWAY,\r\n    \"unclassified\": fowEnum.SINGLE_CARRIAGEWAY,\r\n    \"residential\": fowEnum.SINGLE_CARRIAGEWAY,\r\n\r\n    \"motorway_link\": fowEnum.SLIPROAD,\r\n    \"trunk_link\": fowEnum.SLIPROAD,\r\n    \"primary_link\": fowEnum.SLIPROAD,\r\n    \"secondary_link\": fowEnum.SLIPROAD,\r\n    \"tertiary_link\": fowEnum.SLIPROAD,\r\n\r\n    \"living_street\": fowEnum.OTHER,\r\n    \"service\": fowEnum.OTHER,\r\n    \"pedestrian\": fowEnum.OTHER,\r\n    \"track\": fowEnum.OTHER,\r\n    \"bus_guideway\": fowEnum.OTHER,\r\n    \"excape\": fowEnum.OTHER,\r\n    \"road\": fowEnum.OTHER,\r\n\r\n    \"footway\": fowEnum.OTHER,\r\n    \"bridleway\": fowEnum.OTHER,\r\n    \"steps\": fowEnum.OTHER,\r\n    \"path\": fowEnum.OTHER,\r\n\r\n    \"cycleway\": fowEnum.OTHER,\r\n\r\n    \"proposed\": fowEnum.OTHER,\r\n\r\n    \"construction\": fowEnum.OTHER,\r\n\r\n    \"bus_stop\": fowEnum.OTHER,\r\n    \"crossing\": fowEnum.OTHER,\r\n    \"elevator\": fowEnum.OTHER,\r\n    \"emergency_access_point\": fowEnum.OTHER,\r\n    \"give_way\": fowEnum.OTHER,\r\n    \"mini_roundabout\": fowEnum.ROUNDABOUT,\r\n    \"motorway_junction\": fowEnum.SINGLE_CARRIAGEWAY,\r\n    \"passing_place\": fowEnum.OTHER,\r\n    \"rest_area\": fowEnum.OTHER,\r\n    \"speed_camera\": fowEnum.OTHER,\r\n    \"street_lamp\": fowEnum.OTHER,\r\n    \"services\": fowEnum.OTHER,\r\n    \"stop\": fowEnum.OTHER,\r\n    \"traffic_signals\": fowEnum.OTHER,\r\n    \"turning_circle\": fowEnum.OTHER\r\n};","//based on https://wiki.openstreetmap.org/wiki/Key:highway\r\nimport {frcEnum} from \"../../OpenLR/map/Enum\";\r\n\r\nexport let OsmFrcHighwayMapping = {\r\n    \"motorway\": frcEnum.FRC_0,\r\n    \"trunk\": frcEnum.FRC_1,\r\n    \"primary\": frcEnum.FRC_2,\r\n    \"secondary\": frcEnum.FRC_3,\r\n    \"tertiary\": frcEnum.FRC_4,\r\n    \"unclassified\": frcEnum.FRC_6,\r\n    \"residential\": frcEnum.FRC_5,\r\n\r\n    \"motorway_link\": frcEnum.FRC_0,\r\n    \"trunk_link\": frcEnum.FRC_1,\r\n    \"primary_link\": frcEnum.FRC_2,\r\n    \"secondary_link\": frcEnum.FRC_3,\r\n    \"tertiary_link\": frcEnum.FRC_4,\r\n};","import Line from \"../OpenLR/map/Line\";\r\nimport Node from \"../OpenLR/map/Node\";\r\nimport {fowEnum, frcEnum} from \"../OpenLR/map/Enum\";\r\nimport {OsmFowHighwayMapping} from \"./FOWmappings/OsmFowHighwayMapping\";\r\nimport {OsmFrcHighwayMapping} from \"./FRCmappings/OsmFrcHighwayMapping\";\r\n\r\nexport default class OSMIntegration{\r\n    static initMapDataBase(mapDataBase,nodes,ways,relations){\r\n        let nodesLines = OSMIntegration.getNodesLines(nodes,ways,relations);\r\n        mapDataBase.setData(nodesLines.lines,nodesLines.nodes); //todo: set bounding box\r\n    }\r\n\r\n    static getNodesLines(nodes,ways,relations){\r\n        let openLRLines = {};\r\n        let openLRNodes = {};\r\n        let osmNodes = {};\r\n        for(let id in nodes){\r\n            if(nodes.hasOwnProperty(id)){\r\n                let openLRNode = new Node(id,nodes[id][\"@_lat\"],nodes[id][\"@_lon\"]);\r\n                osmNodes[openLRNode.getID()] = openLRNode;\r\n            }\r\n        }\r\n        for(let id in ways){\r\n            if(ways.hasOwnProperty(id)){\r\n                for(let i =0;i<ways[id].nd.length-1;i++){\r\n                    // add a line from this node to the next one\r\n                    // the id of the line is created out of the id of the way + underscore + id of the start node (since these lines aren't directly identified in osm)\r\n                    let openLRLine = new Line(id+\"_\"+ways[id].nd[i][\"@_ref\"],osmNodes[ways[id].nd[i][\"@_ref\"]],osmNodes[ways[id].nd[i+1][\"@_ref\"]]);\r\n                    openLRLine.frc = OSMIntegration.getFRC(ways[id]);\r\n                    openLRLine.fow = OSMIntegration.getFOW(ways[id]);\r\n                    openLRLines[openLRLine.getID()] = openLRLine;\r\n\r\n                    // check if OSM does specify if this is strictly a one way street\r\n                    let oneWay = false;\r\n                    if(Array.isArray(ways[id].tag)){\r\n                        let i=0;\r\n                        let oneWayTagFound = false;\r\n                        while(!oneWayTagFound && i<ways[id].tag.length){\r\n                            if(ways[id].tag[i][\"@_k\"]===\"oneway\"){\r\n                                oneWayTagFound = true;\r\n                                if(ways[id].tag[i][\"@_v\"]===\"yes\"){\r\n                                    oneWay = true;\r\n                                }\r\n                            }\r\n                            i++;\r\n                        }\r\n                    }\r\n                    else if(ways[id].tag[\"@_k\"]===\"oneway\" && ways[id].tag[\"@_v\"]===\"yes\"){\r\n                        oneWay = true;\r\n                    }\r\n\r\n                    if(!oneWay){\r\n                        // since OSM doesn't have directed lines for it's roads, we will add the line in the other direction, so it is always present both as an input line and an output line in a node\r\n                        let reverseOpenLRLine = new Line(id+\"_\"+ways[id].nd[i][\"@_ref\"]+\"_1\",osmNodes[ways[id].nd[i+1][\"@_ref\"]],osmNodes[ways[id].nd[i][\"@_ref\"]]);\r\n                        reverseOpenLRLine.frc = OSMIntegration.getFRC(ways[id]);\r\n                        reverseOpenLRLine.fow = OSMIntegration.getFOW(ways[id]);\r\n                        openLRLines[reverseOpenLRLine.getID()] = reverseOpenLRLine;\r\n                    }\r\n\r\n                    //since we only want to keep the nodes that are part of the road network, and not the other nodes of OSM, so we will add only those in the openLRNodes map\r\n                    openLRNodes[ways[id].nd[i][\"@_ref\"]] = osmNodes[ways[id].nd[i][\"@_ref\"]];\r\n                    openLRNodes[ways[id].nd[i+1][\"@_ref\"]] = osmNodes[ways[id].nd[i+1][\"@_ref\"]];\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            nodes: openLRNodes,\r\n            lines: openLRLines\r\n        }\r\n    }\r\n\r\n    /*depricated, old code, only used to test that one way doesn't affect lanes that aren't one way only*/\r\n    static initMapDataBaseDeprecatedNoOneWay(mapDataBase, nodes, ways, relations){\r\n        let nodesLines = OSMIntegration.getNodesLinesDeprecatedNoOneWay(nodes,ways,relations);\r\n        mapDataBase.setData(nodesLines.lines,nodesLines.nodes);\r\n    }\r\n\r\n    static getNodesLinesDeprecatedNoOneWay(nodes,ways,realtions){\r\n        let openLRLines = {};\r\n        let openLRNodes = {};\r\n        let osmNodes = {};\r\n        for(let id in nodes){\r\n            if(nodes.hasOwnProperty(id)){\r\n                let openLRNode = new Node(id,nodes[id][\"@_lat\"],nodes[id][\"@_lon\"]);\r\n                osmNodes[openLRNode.getID()] = openLRNode;\r\n            }\r\n        }\r\n        for(let id in ways){\r\n            if(ways.hasOwnProperty(id)){\r\n                for(let i =0;i<ways[id].nd.length-1;i++){\r\n                    // add a line from this node to the next one\r\n                    // the id of the line is created out of the id of the way + underscore + id of the start node (since these lines aren't directly identified in osm)\r\n                    let openLRLine = new Line(id+\"_\"+ways[id].nd[i][\"@_ref\"],osmNodes[ways[id].nd[i][\"@_ref\"]],osmNodes[ways[id].nd[i+1][\"@_ref\"]]);\r\n                    openLRLine.frc = OSMIntegration.getFRC(ways[id]);\r\n                    openLRLine.fow = OSMIntegration.getFOW(ways[id]);\r\n                    openLRLines[openLRLine.getID()] = openLRLine;\r\n\r\n                    // since OSM doesn't have directed lines for it's roads, we will add the line in the other direction, so it is always present both as an input line and an output line in a node\r\n                    let reverseOpenLRLine = new Line(id+\"_\"+ways[id].nd[i][\"@_ref\"]+\"_1\",osmNodes[ways[id].nd[i+1][\"@_ref\"]],osmNodes[ways[id].nd[i][\"@_ref\"]]);\r\n                    reverseOpenLRLine.frc = OSMIntegration.getFRC(ways[id]);\r\n                    reverseOpenLRLine.fow = OSMIntegration.getFOW(ways[id]);\r\n                    openLRLines[reverseOpenLRLine.getID()] = reverseOpenLRLine;\r\n\r\n                    //since we only want to keep the nodes that are part of the road network, and not the other nodes of OSM, so we will add only those in the openLRNodes map\r\n                    openLRNodes[ways[id].nd[i][\"@_ref\"]] = osmNodes[ways[id].nd[i][\"@_ref\"]];\r\n                    openLRNodes[ways[id].nd[i+1][\"@_ref\"]] = osmNodes[ways[id].nd[i+1][\"@_ref\"]];\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            nodes: openLRNodes,\r\n            lines: openLRLines\r\n        }\r\n    }\r\n\r\n    static getFRC(osmWay){\r\n        let value = OSMIntegration._getTagsValues(osmWay,\"highway\");\r\n        if(value[\"highway\"] !== undefined && OsmFrcHighwayMapping[value[\"highway\"]] !== undefined){\r\n            return OsmFrcHighwayMapping[value[\"highway\"]];\r\n        }\r\n        else {\r\n            return frcEnum.FRC_7;\r\n        }\r\n    }\r\n\r\n    static getFOW(osmWay){\r\n        let value = OSMIntegration._getTagsValues(osmWay,\"highway\",\"junction\",\"area\");\r\n        if(value[\"highway\"] !== undefined\r\n            && value[\"highway\"] === \"pedestrian\"\r\n            && value[\"area\"] !== undefined\r\n            && value[\"area\"] === \"yes\")\r\n        {\r\n            return fowEnum.TRAFFICSQUARE;\r\n        }\r\n        else if(value[\"junction\"] !== undefined && value[\"junction\"] === \"roundabout\"){\r\n            return fowEnum.ROUNDABOUT;\r\n        }\r\n        else if(value[\"highway\"] !== undefined && OsmFowHighwayMapping[value[\"highway\"]] !== undefined){\r\n            return OsmFowHighwayMapping[value[\"highway\"]];\r\n        }\r\n        else {\r\n            return fowEnum.UNDEFINED;\r\n        }\r\n    }\r\n\r\n    static _getTagsValues(osmWay,tags){\r\n        let value = {};\r\n        if(Array.isArray(osmWay.tag)){\r\n            let i=0;\r\n            while(i < osmWay.tag.length){\r\n                if(tags.includes(osmWay.tag[i][\"@_k\"])){\r\n                    if(value[osmWay.tag[i][\"@_k\"]] !== undefined){\r\n                        console.warn(\"Multiple '\",osmWay.tag[i][\"@_k\"],\"' tags found for way:\",osmWay);\r\n                    }\r\n                    value[osmWay.tag[i][\"@_k\"]] = osmWay.tag[i][\"@_v\"];\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n        else if(tags.includes(osmWay.tag[\"@_k\"])){\r\n            value[osmWay.tag[\"@_k\"]] = osmWay.tag[\"@_v\"];\r\n        }\r\n        return value;\r\n    }\r\n}","import Heap from 'heap'\r\nimport {frcEnum} from \"../map/Enum\";\r\n\r\nexport default class Dijkstra{\r\n    static shortestPath(startNode,endNode,options){\r\n        if(startNode.getID() === endNode.getID()){\r\n            return {\r\n                lines: [],\r\n                length: 0 //integer value in the unit of internal precision!\r\n            }\r\n        }\r\n\r\n        let minLengths = {};\r\n        let followedLine = {};\r\n\r\n        let heap = new Heap(function (a, b) {\r\n            if(a[0] < b[0]){\r\n                return -1;\r\n            }\r\n            if(b[0] < a[0]){\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n\r\n        // push start node on heap with length 0\r\n        heap.push([0,startNode]);\r\n        minLengths[startNode.getID()] = 0;\r\n        while(heap.size() > 0){\r\n            let heapTop = heap.pop();\r\n            let currentNode = heapTop[1];\r\n\r\n            currentNode.getOutgoingLines().forEach(function (line) {\r\n                let length = minLengths[currentNode.getID()] + line.getLength();\r\n                if(length<0){\r\n                    throw Error(\"negative line length found for line: \"+line.getID());\r\n                }\r\n                let validLine = (options === undefined || options.lfrcnp === undefined || options.lfrcnpDiff === undefined || line.getFRC() === undefined)? 1\r\n                    : 0 || (line.getFRC() >= frcEnum.FRC_0 && line.getFRC() <= frcEnum.FRC_7\r\n                    && line.getFRC() <= options.lfrcnpDiff+options.lfrcnp);\r\n                if(validLine && (minLengths[line.getEndNode().getID()] === undefined\r\n                    || minLengths[line.getEndNode().getID()] > length)){\r\n                    minLengths[line.getEndNode().getID()] = length;\r\n                    followedLine[line.getEndNode().getID()] = line;\r\n                    if(minLengths[endNode.getID()] === undefined || length < minLengths[endNode.getID()]){\r\n                        // this Dijkstra algorithm is only interested in the shortest path between the startNode and the endNode,\r\n                        // not in the shortest paths between the startNode and any other node, so if a length is already longer\r\n                        // than the current shortest path to the endNode, we won't push it to the stack\r\n\r\n                        if(options !== undefined && options.maxDist !== undefined){\r\n                            // if a max distance is given, the shortest path can not be longer than this max distance\r\n                            // (which means that nodes that have a eagle's eye distance longer than this max distance)\r\n                            // which means that nodes that have a distance that already is longer than this max distance\r\n                            // will never be part of the shortest path we want to calculate\r\n                            //\r\n                            // , and the shortest path foound in this way would always be discarded\r\n                            // since the total distance would always be longer than\r\n                            // the max distance (which is the distanceToNextLrp + decoderProperties.dist)\r\n                            // OR\r\n                            // , (when using in Encoder) we know the shortest path we want in advance and calculate it's\r\n                            // length (the length between the very first and very last LRP) and use that as the maximum\r\n                            //\r\n                            // so we can speed up this SP calculation by not taking these nodes into account\r\n                            if(length <= options.maxDist){\r\n                                heap.push([length,line.getEndNode()]);\r\n                            }\r\n                        }\r\n                        else{\r\n                            heap.push([length,line.getEndNode()]);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        let shortestPathLines = [];\r\n        let lastStep = endNode;\r\n\r\n        while(lastStep.getID() !== startNode.getID() && followedLine[lastStep.getID()] !== undefined){\r\n            let line = followedLine[lastStep.getID()];\r\n            shortestPathLines.unshift(line);\r\n            lastStep = line.getStartNode();\r\n        }\r\n\r\n        //if length is 0, and lines = [], the startnode was equal to the endnode\r\n        //if length is undefined and lines = [], there isn't a path between the startnode and endnode\r\n        if(minLengths[endNode.getID()] === 0){\r\n            throw Error(\"Something went wrong during Shortest Path calculation, probably because lines exist with 0 or negative lengths\");\r\n        }\r\n        return {\r\n            lines: shortestPathLines,\r\n            length: minLengths[endNode.getID()] //integer value in meter!\r\n        }\r\n    }\r\n}","import {fowEnum, frcEnum} from \"../map/Enum\";\r\nimport Dijkstra from \"./Dijkstra\";\r\nimport {configProperties} from \"./CoderSettings\";\r\n\r\nexport default class LineDecoder{\r\n\r\n\r\n    static decode(mapDataBase,LRPs,posOffset,negOffset,decoderProperties){\r\n        // 2: For each location reference point find candidate nodes\r\n        let candidateNodes = LineDecoder.findCandidatesOrProjections(mapDataBase,LRPs,decoderProperties);\r\n\r\n        // 3: For each location reference point find candidate lines\r\n        // 4: Rate candidate lines for each location reference point\r\n        let candidateLines = LineDecoder.findCandidateLines(LRPs,candidateNodes,decoderProperties);\r\n\r\n        // 5: Determine shortest-path(s) between two subsequent location reference points\r\n        // 6: Check validity of the calculated shortest-path(s)\r\n        // 7: Concatenate shortest-path(s) to form the location\r\n        let concatShortestPath = LineDecoder.determineShortestPaths(candidateLines,LRPs,decoderProperties);\r\n\r\n        // 7: and trim according to the offsets\r\n        let offsets = {\r\n            posOffset: Math.round(posOffset*configProperties.internalPrecision),\r\n            negOffset: Math.round(negOffset*configProperties.internalPrecision)\r\n        };\r\n        LineDecoder.trimAccordingToOffsets(concatShortestPath,offsets,decoderProperties);\r\n\r\n        return {\r\n            lines: concatShortestPath.shortestPath,\r\n            posOffset: Math.round(offsets.posOffset/configProperties.internalPrecision),\r\n            negOffset: Math.round(offsets.negOffset/configProperties.internalPrecision)\r\n        }\r\n    }\r\n\r\n    static findCandidatesOrProjections(mapDataBase,LRPs,decoderProperties){\r\n        let candidates = [];\r\n        for(let i=0;i<LRPs.length;i++){\r\n            candidates[i] = [];\r\n            //find nodes whereby the coordinates of the candidate nodes are close to the coordinates of the location reference point\r\n            let nodes = mapDataBase.findNodesCloseByCoordinate(LRPs[i].lat,LRPs[i].long,decoderProperties.dist*configProperties.internalPrecision);\r\n\r\n            //if no candidate nodes are found\r\n            //the direct search of lines using a projection point may also be executed even if candidate nodes are found. (set in decoderProperties)\r\n            if(nodes.length !== 0){\r\n                Array.prototype.push.apply(candidates[i],nodes);\r\n            }\r\n            if(nodes.length === 0 || decoderProperties.alwaysUseProjections){\r\n                //determine candidate line directly by projecting the LRP on a line not far away form the coordinate\r\n                let closeByLines = mapDataBase.findLinesCloseByCoordinate(LRPs[i].lat,LRPs[i].long,decoderProperties.dist*configProperties.internalPrecision);\r\n                if(closeByLines.length === 0 && nodes.length === 0){\r\n                    throw Error(\"No candidate nodes or projected nodes can be found.\");\r\n                }\r\n                let projectedPoints = [];\r\n                closeByLines.forEach(function (line) {\r\n                    let location = line.line.measureAlongLine(LRPs[i].lat,LRPs[i].long);\r\n                    if(location.lat === line.line.getStartNode().getLatitudeDeg()\r\n                        || location.lat === line.line.getEndNode().getLatitudeDeg()\r\n                        || location.long === line.line.getStartNode().getLongitudeDeg()\r\n                        || location.long === line.line.getEndNode().getLongitudeDeg()\r\n                    ){\r\n                        //console.log(\"The found projection point is the same as the start or end node of the line, so it should already be covered by the findNodesCloseByCoordinate function.\");\r\n                    }\r\n                    else{\r\n                        location.line = line.line;\r\n                        location.dist = line.dist;\r\n                        projectedPoints.push(location);\r\n                    }\r\n\r\n                });\r\n                Array.prototype.push.apply(candidates[i],projectedPoints);\r\n            }\r\n        }\r\n        return candidates;\r\n    }\r\n\r\n    //lat, long and bearing should never be undefined\r\n    static findCandidateLines(LRPs,candidateNodes,decoderProperties){\r\n        let candidateLines = [];\r\n        for(let i=0;i<LRPs.length;i++){\r\n            candidateLines[i] = [];\r\n            //check the outgoing lines of the candidateNodes\r\n            candidateNodes[i].forEach((node)=>{\r\n                if(node.node === undefined){\r\n                    //the node is a projection point\r\n                    let bearDiff = i===LRPs.length-1\r\n                        ? Math.abs(node.line.getReverseBearing()-LRPs[LRPs.length-1].bearing)\r\n                        : Math.abs(node.line.getBearing()-LRPs[i].bearing);\r\n                    let frcDiff;\r\n                    if(decoderProperties.useFrcFow && node.line.getFRC() !== undefined && node.line.getFRC() >= frcEnum.FRC_0\r\n                        && node.line.getFRC() <= frcEnum.FRC_7 && LRPs[i].frc !== undefined){\r\n                        frcDiff = Math.abs(node.line.getFRC()-LRPs[i].frc);\r\n                    }\r\n                    // note: fow isn't hierarchical, so a difference can't be computed\r\n                    if(bearDiff <= decoderProperties.bearDiff\r\n                        && (frcDiff === undefined ? true : frcDiff <= decoderProperties.frcDiff)){\r\n                        //the bearing,frc and fow values are close so this line could be a good candidate\r\n                        let candidate = {\r\n                            line: node.line,\r\n                            bearDiff: bearDiff,\r\n                            frcDiff: frcDiff,\r\n                            lrpIndex: i,\r\n                            projected: true,\r\n                            rating: undefined,\r\n                            // if the node is projected, not the full length of the line should be taken in the calculation of the distance between LRPs,\r\n                            // but only to (or from) the location of the projected point\r\n                            distToProjection: node.line.getStartNode().getDistance(node.lat,node.long)\r\n                        };\r\n                        candidate.rating = LineDecoder.rateCandidateLine(candidate,node.dist,LRPs[candidate.lrpIndex],decoderProperties);\r\n                        candidateLines[i].push(candidate);\r\n                    }\r\n                }\r\n                else{\r\n                    //the node exists in the database and possibly has multiple outgoing lines\r\n                    let lines = i===LRPs.length-1\r\n                        ? node.node.getIncomingLines()\r\n                        : node.node.getOutgoingLines();\r\n                    //for the last LRP, check the incoming lines\r\n                    lines.forEach((line)=>{\r\n                        let bearDiff = i===LRPs.length-1\r\n                            ? Math.abs(line.getReverseBearing()-LRPs[LRPs.length-1].bearing)\r\n                            : Math.abs(line.getBearing()-LRPs[i].bearing);\r\n                        let frcDiff;\r\n                        if(decoderProperties.useFrcFow && line.getFRC() !== undefined && line.getFRC() >= frcEnum.FRC_0\r\n                            && line.getFRC() <= frcEnum.FRC_7 && LRPs[i].frc !== undefined){\r\n                            frcDiff = Math.abs(line.getFRC()-LRPs[i].frc);\r\n                        }\r\n                        if( bearDiff <= decoderProperties.bearDiff\r\n                            && (frcDiff === undefined ? true : frcDiff <= decoderProperties.frcDiff)){\r\n                            //the bearing,frc and fow values are close so this line could be a good candidate\r\n                            let candidate = {\r\n                                line: line,\r\n                                bearDiff: bearDiff,\r\n                                frcDiff: frcDiff,\r\n                                lrpIndex: i,\r\n                                projected: false,\r\n                                rating: undefined,\r\n                                //if the LRP was not projected, use the node ID to detect if multiple LRPs would be mapped to the same node (WITHOUT PROJECTIONS)\r\n                                candidateNodeID: node.node.getID()\r\n                            };\r\n                            candidate.rating = LineDecoder.rateCandidateLine(candidate,node.dist,LRPs[candidate.lrpIndex],decoderProperties);\r\n                            candidateLines[i].push(candidate);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n            //if no candidate line can be found for a location reference point, the decoder should\r\n            //report an error and stop further processing\r\n            if(candidateLines[i].length === 0){\r\n                throw Error(\"No candidate lines found for LRP\");\r\n            }\r\n            LineDecoder.sortLines(candidateLines[i]);\r\n        }\r\n        return candidateLines;\r\n    }\r\n\r\n    static sortLines(lines){\r\n        //sort candidate lines on closest matching based on distance, bearing, frc and fow\r\n        lines.sort((a,b)=>{\r\n            //the lower the rating, the better the match is\r\n            return a.rating - b.rating;\r\n        });\r\n    }\r\n\r\n    static rateCandidateLine(candidateLine,distance,lrp,decoderProperties){\r\n        let rating = 0;\r\n        let maxRating = 0;\r\n        // the start node, end node for the last location reference point or projection point\r\n        // shall be as close as possible to the coordinates of the location reference point\r\n        // let distance = Math.abs(calcDistance(matchingNode.lat,matchingNode.long,lrp.lat,lrp.long));\r\n        // distance = Math.abs(distance);\r\n        let distanceRating = distance/(decoderProperties.dist*configProperties.internalPrecision);\r\n        rating += distanceRating * decoderProperties.distMultiplier;\r\n        maxRating += decoderProperties.distMultiplier;\r\n        // the functional road class of the candidate line should match the functional road class\r\n        // of the location reference point\r\n        if(decoderProperties.useFrcFow && candidateLine.frcDiff !== undefined){\r\n            let frcRating = candidateLine.frcDiff/decoderProperties.frcDiff;\r\n            rating += frcRating * decoderProperties.frcMultiplier;\r\n            maxRating += decoderProperties.frcMultiplier;\r\n        }\r\n        // the form of way of the candidate line should match the form of way of the location reference point\r\n        // form of way isn't hierarchical so it either does or does not match\r\n        if(decoderProperties.useFrcFow && candidateLine.line.getFOW() !== undefined && candidateLine.line.getFOW() >= fowEnum.UNDEFINED\r\n            && candidateLine.line.getFOW() <= fowEnum.OTHER && lrp.fow !== undefined && lrp.fow >= fowEnum.UNDEFINED\r\n            && lrp.fow <= fowEnum.OTHER){\r\n            let fowRating = candidateLine.line.getFOW() === lrp.fow ? 0 : 1;\r\n            rating += fowRating * decoderProperties.fowMultiplier;\r\n            maxRating += decoderProperties.fowMultiplier;\r\n        }\r\n        //the bearing of the candidate line should match indicated bearing angles of the location reference point\r\n        let bearRating = candidateLine.bearDiff/decoderProperties.bearDiff;\r\n        rating += bearRating * decoderProperties.bearMultiplier;\r\n        maxRating += decoderProperties.bearMultiplier;\r\n        return rating/maxRating;\r\n    }\r\n\r\n    static findShortestPath(startLine,endLine,lfrcnp,decoderProperties,distanceToNext){\r\n        // if(startLine.startNode === endLine.endNode){\r\n        //     console.log(\"The first LRP starts in the same point where the second LRP ends. If no valid shortest path is found, retry with projections.\");\r\n        // }\r\n        if(startLine.getID()===endLine.getID()){\r\n            return {lines: [], length: 0};\r\n        }\r\n        else{\r\n            return Dijkstra.shortestPath(\r\n                startLine.getEndNode(),\r\n                endLine.getStartNode(),\r\n                {\r\n                    lfrcnp: decoderProperties.useFrcFow ? lfrcnp : undefined,\r\n                    lfrcnpDiff: decoderProperties.useFrcFow ? decoderProperties.lfrcnpDiff : undefined,\r\n                    maxDist: distanceToNext !== undefined ? decoderProperties.distanceToNextDiff*configProperties.internalPrecision + distanceToNext : undefined\r\n                });\r\n        }\r\n    }\r\n\r\n    static calcSPforLRP(candidateLines,candidateIndexes,lrpIndex,tries,shortestPaths,LRPs,decoderProperties){\r\n        if(lrpIndex>=LRPs.length-1){\r\n            throw Error(\"SP calculation should not happen for the last LRP\");\r\n        }\r\n        let shortestPath = undefined;\r\n        if(candidateIndexes[lrpIndex]===undefined){\r\n            candidateIndexes[lrpIndex] = 0;\r\n        }\r\n        if(candidateIndexes[lrpIndex+1]===undefined){\r\n            candidateIndexes[lrpIndex+1] = 0;\r\n        }\r\n        let prevEndChanged = false;\r\n        let prevEndCandidateIndex = candidateIndexes[lrpIndex+1];\r\n        let distanceBetweenLRP = undefined;\r\n\r\n        let distanceBetweenLRPCompensation = 0;\r\n\r\n        while(shortestPath === undefined   //first time shortestPath is always undefined, so this loop runs minimum 1 time\r\n            && tries.count < decoderProperties.maxSPSearchRetries){\r\n            shortestPath = LineDecoder.findShortestPath(candidateLines[lrpIndex][candidateIndexes[lrpIndex]].line,candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].line,LRPs[lrpIndex].lfrcnp,decoderProperties,LRPs[lrpIndex].distanceToNext*configProperties.internalPrecision);\r\n\r\n            // if the current and next LRP had the same real (NOT PROJECTED) node, the distance between them should be 0\r\n            if(candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].projected === false //the current LRP is not projected\r\n                && candidateLines[lrpIndex][candidateIndexes[lrpIndex]].projected === false //the next LRP is not projected\r\n                && candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].candidateNodeID === candidateLines[lrpIndex][candidateIndexes[lrpIndex]].candidateNodeID //their conforming node is the same\r\n            ){\r\n                // the distance to the next LRP is 0. The findShortestPath method should have returned {lines: [], length: 0}.\r\n                distanceBetweenLRP = 0;\r\n            }\r\n            else {\r\n                // the total length of the first line can be added to distanceBetweenLRP\r\n                distanceBetweenLRP = candidateLines[lrpIndex][candidateIndexes[lrpIndex]].line.getLength();\r\n            }\r\n\r\n            if(candidateLines[lrpIndex][candidateIndexes[lrpIndex]].projected === true){\r\n                // this first line was found by using a projection, the total distance between this LRP and the next should be lowered\r\n                // by the length at which the projection can be found\r\n                distanceBetweenLRPCompensation += (-1 * candidateLines[lrpIndex][candidateIndexes[lrpIndex]].distToProjection);\r\n            }\r\n\r\n            if(candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].projected === true){\r\n                // next line was found by using a projection, the total distance between this LRP and the next should be heightened\r\n                // by the length at which the projection can be found\r\n                distanceBetweenLRPCompensation += (+1 * candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].distToProjection);\r\n                // if the next line was the same as this line, the length of the line should be subtracted\r\n                // because we already added it's length to distanceBetweenLRP\r\n                if(candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].line.getID() === candidateLines[lrpIndex][candidateIndexes[lrpIndex]].line.getID()){\r\n                    distanceBetweenLRP -= candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].line.getLength();\r\n                }\r\n            }\r\n\r\n            if(lrpIndex === LRPs.length-2\r\n                // if this is the second last LRP\r\n                && candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].line.getID() !== candidateLines[lrpIndex][candidateIndexes[lrpIndex]].line.getID()\r\n                // and the line of this LRP isn't the same as the line of the last LRP (if it would be the same, it's length was already added)\r\n                && candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].projected === false\r\n                // the length of the last line shouldn't be added if it was projected, because it's length is already compensated in distanceBetweenLRPCompensation\r\n            ){\r\n                distanceBetweenLRP += candidateLines[lrpIndex+1][candidateIndexes[lrpIndex+1]].line.getLength();\r\n            }\r\n\r\n            if(shortestPath.length !== undefined){\r\n                //if the shortest path has a length, it should be added to distanceBetweenLRP\r\n                //if it doesn't, the while loop will restart because shortestPath.length === undefined\r\n                distanceBetweenLRP += shortestPath.length;\r\n            }\r\n\r\n            // console.warn(distanceBetweenLRP,distanceBetweenLRPCompensation,LRPs[lrpIndex].distanceToNext,decoderProperties.distanceToNextDiff);\r\n            if(shortestPath === undefined\r\n                || shortestPath.length === undefined\r\n                || Math.abs(distanceBetweenLRP+distanceBetweenLRPCompensation-LRPs[lrpIndex].distanceToNext*configProperties.internalPrecision) >= decoderProperties.distanceToNextDiff*configProperties.internalPrecision) // check validity (step 6 of decoding)\r\n            {\r\n                if(candidateIndexes[lrpIndex+1] < candidateLines[lrpIndex+1].length-1){\r\n                    //we can try a different end line (which has our preference because it can't change previous path calculations)\r\n                    candidateIndexes[lrpIndex+1]++;\r\n                    //manually reset shortestPath to trigger while loop rerun\r\n                    shortestPath = undefined;\r\n                }\r\n                else if(candidateIndexes[lrpIndex] < candidateLines[lrpIndex].length-1){\r\n                    //we can try a different start line (which might change the end line of the shortest path calculation of our previous LRP)\r\n                    candidateIndexes[lrpIndex]++;\r\n                    //we should reset the index of the end line to the previously tried end line\r\n                    //is 0 unless this method is called recursively because our end line changed further in the LRP list\r\n                    candidateIndexes[lrpIndex+1] = prevEndCandidateIndex;\r\n                    prevEndChanged = true;\r\n                    //manually reset shortestPath to trigger while loop rerun\r\n                    shortestPath = undefined;\r\n                }\r\n                else{\r\n                    throw Error(\"No shortest path could be found between the given LRPs with indexes \" +lrpIndex +\" and \" + (lrpIndex+1) +\r\n                        \" You either tried to decode a loop that isn't present in the current map \" +\r\n                        \"or you tried decoding a line between two points that are to close together and decoded as a single node\");\r\n                }\r\n            }\r\n            tries.count++;\r\n        }\r\n        if(shortestPath === undefined || shortestPath.length === undefined){\r\n            throw Error(\"could not construct a shortest path in the given amount of tries between the given LRPs with indexes \" +lrpIndex +\" and \" + (lrpIndex+1));\r\n        }\r\n        shortestPaths[lrpIndex] = shortestPath;\r\n        if(prevEndChanged && lrpIndex-1 >= 0){\r\n            // we changed the start line of for this LRP, which means the end line of the last LRP is changed and it's shortest path should be recalculated\r\n            // this can happen recursively until we reach our first LRP\r\n            // console.log(\"Start Line adjusted, recalculate path for previous LRP\");\r\n            shortestPaths[lrpIndex-1] = LineDecoder.calcSPforLRP(candidateLines,candidateIndexes,lrpIndex-1,tries,shortestPaths,LRPs,decoderProperties);\r\n        }\r\n    }\r\n\r\n    static determineShortestPaths(candidateLines,LRPs,decoderProperties){\r\n        let shortestPaths = [];\r\n        let candidateIndexes = [];\r\n        let tries = {count: 0};\r\n        for(let i=0;i<candidateLines.length-1;i++){\r\n            LineDecoder.calcSPforLRP(candidateLines,candidateIndexes,i,tries,shortestPaths,LRPs,decoderProperties);\r\n        }\r\n\r\n        return LineDecoder.concatSP(shortestPaths, candidateLines, candidateIndexes);\r\n    }\r\n\r\n    static concatSP(shortestPaths,candidateLines,candidateIndexes){\r\n        if(shortestPaths.length !== candidateLines.length-1){\r\n            throw Error(\"length of shortestPaths !== length of candidateLines-1\");\r\n        }\r\n        let concatenatedShortestPath = [];\r\n        for(let i=0;i<shortestPaths.length;i++){\r\n            if(concatenatedShortestPath.length === 0 || candidateLines[i][candidateIndexes[i]].line.getID() !== concatenatedShortestPath[concatenatedShortestPath.length-1].getID()){\r\n                // if the line to add isn't the same as the last line added (could be the same if two LRPs are mapped or projected on the same line)\r\n                concatenatedShortestPath.push(candidateLines[i][candidateIndexes[i]].line); //add the startLine of the LRP (endline if last LRP)\r\n            }\r\n            for(let j=0;j<shortestPaths[i].lines.length;j++){\r\n                concatenatedShortestPath.push(shortestPaths[i].lines[j])\r\n            }\r\n        }\r\n        if(concatenatedShortestPath.length === 0 || candidateLines[candidateLines.length-1][candidateIndexes[candidateIndexes.length-1]].line.getID() !== concatenatedShortestPath[concatenatedShortestPath.length-1].getID()){\r\n            // if the line to add isn't the same as the last line added (could be the same if two LRPs are mapped or projected on the same line)\r\n            concatenatedShortestPath.push(candidateLines[candidateLines.length-1][candidateIndexes[candidateIndexes.length-1]].line); // add the line of the last LRP\r\n        }\r\n        return {\r\n            shortestPath: concatenatedShortestPath,\r\n            posProjDist: candidateLines[0][candidateIndexes[0]].distToProjection === undefined\r\n                ? 0\r\n                : candidateLines[0][candidateIndexes[0]].distToProjection,\r\n            negProjDist: candidateLines[candidateLines.length-1][candidateIndexes[candidateIndexes.length-1]].distToProjection === undefined\r\n                ? 0\r\n                : candidateLines[candidateLines.length-1][candidateIndexes[candidateIndexes.length-1]].line.getLength() - candidateLines[candidateLines.length-1][candidateIndexes[candidateIndexes.length-1]].distToProjection\r\n        };\r\n    }\r\n\r\n    // static trimAccordingToOffsets(concatShortestPath,offsets){\r\n    //     offsets.posOffset+=concatShortestPath.posProjDist;\r\n    //     offsets.negOffset+=concatShortestPath.negProjDist;\r\n    //     if(concatShortestPath.shortestPath.length === 0){\r\n    //         throw Error(\"can't trim empty path\");\r\n    //     }\r\n    //     let firstLine = concatShortestPath.shortestPath[0];\r\n    //     while(offsets.posOffset > 0 && firstLine !== undefined && firstLine.getLength()<=offsets.posOffset){\r\n    //         offsets.posOffset  -= firstLine.getLength();\r\n    //         concatShortestPath.shortestPath.shift();\r\n    //         firstLine = concatShortestPath.shortestPath[0];\r\n    //     }\r\n    //     let lastLine = concatShortestPath.shortestPath[concatShortestPath.shortestPath.length-1];\r\n    //     while(offsets.negOffset > 0 && lastLine !== undefined && lastLine.getLength()<=offsets.negOffset){\r\n    //         offsets.negOffset -= lastLine.getLength();\r\n    //         concatShortestPath.shortestPath.pop();\r\n    //         lastLine = concatShortestPath.shortestPath[concatShortestPath.shortestPath.length-1];\r\n    //     }\r\n    //     if(concatShortestPath.shortestPath.length === 0){\r\n    //         throw Error(\"The remaining shortest path after trimming according to offsets is empty.\");\r\n    //     }\r\n    // }\r\n\r\n    // static trimAccordingToOffsets(concatShortestPath,offsets,decoderProperties){\r\n    //     offsets.posOffset+=concatShortestPath.posProjDist;\r\n    //     offsets.negOffset+=concatShortestPath.negProjDist;\r\n    //     if(concatShortestPath.shortestPath.length === 0){\r\n    //         throw Error(\"can't trim empty path\");\r\n    //     }\r\n    //     let firstLine = concatShortestPath.shortestPath[0];\r\n    //     while(offsets.posOffset > 0 && firstLine !== undefined && firstLine.getLength()<=offsets.posOffset && offsets.posOffset-firstLine.getLength() >= (decoderProperties.distanceToNextDiff*decoderProperties.internalPrecision)){\r\n    //         offsets.posOffset  -= firstLine.getLength();\r\n    //         concatShortestPath.shortestPath.shift();\r\n    //         firstLine = concatShortestPath.shortestPath[0];\r\n    //     }\r\n    //     let lastLine = concatShortestPath.shortestPath[concatShortestPath.shortestPath.length-1];\r\n    //     while(offsets.negOffset > 0 && lastLine !== undefined && lastLine.getLength()<=offsets.negOffset && offsets.negOffset-lastLine.getLength() >= (decoderProperties.distanceToNextDiff*decoderProperties.internalPrecision)){\r\n    //         offsets.negOffset -= lastLine.getLength();\r\n    //         concatShortestPath.shortestPath.pop();\r\n    //         lastLine = concatShortestPath.shortestPath[concatShortestPath.shortestPath.length-1];\r\n    //     }\r\n    //     if(concatShortestPath.shortestPath.length === 0){\r\n    //         throw Error(\"The remaining shortest path after trimming according to offsets is empty.\");\r\n    //     }\r\n    // }\r\n\r\n    static trimAccordingToOffsets(concatShortestPath,offsets){\r\n        offsets.posOffset+=concatShortestPath.posProjDist;\r\n        offsets.negOffset+=concatShortestPath.negProjDist;\r\n        if(concatShortestPath.shortestPath.length === 0){\r\n            throw Error(\"can't trim empty path\");\r\n        }\r\n        let firstLine = concatShortestPath.shortestPath[0];\r\n        let lastLine = concatShortestPath.shortestPath[concatShortestPath.shortestPath.length-1];\r\n        let posOffsetOverflow = offsets.posOffset > 0 && firstLine !== undefined && firstLine.getLength()<=offsets.posOffset;\r\n        let negOffsetOverflow = offsets.negOffset > 0 && lastLine !== undefined && lastLine.getLength()<=offsets.negOffset;\r\n        while(concatShortestPath.shortestPath.length > 1 && (posOffsetOverflow || negOffsetOverflow)){\r\n            if(posOffsetOverflow && negOffsetOverflow){\r\n                let posOverflow = offsets.posOffset-firstLine.getLength();\r\n                let negOverflow = offsets.negOffset-lastLine.getLength();\r\n                if(posOverflow>=negOverflow){\r\n                    offsets.posOffset  -= firstLine.getLength();\r\n                    concatShortestPath.shortestPath.shift();\r\n                    firstLine = concatShortestPath.shortestPath[0];\r\n                }\r\n                else{\r\n                    offsets.negOffset -= lastLine.getLength();\r\n                    concatShortestPath.shortestPath.pop();\r\n                    lastLine = concatShortestPath.shortestPath[concatShortestPath.shortestPath.length-1];\r\n                }\r\n            }\r\n            else if(posOffsetOverflow){\r\n                offsets.posOffset  -= firstLine.getLength();\r\n                concatShortestPath.shortestPath.shift();\r\n                firstLine = concatShortestPath.shortestPath[0];\r\n            }\r\n            else if(negOffsetOverflow){\r\n                offsets.negOffset -= lastLine.getLength();\r\n                concatShortestPath.shortestPath.pop();\r\n                lastLine = concatShortestPath.shortestPath[concatShortestPath.shortestPath.length-1];\r\n            }\r\n            posOffsetOverflow = offsets.posOffset > 0 && firstLine !== undefined && firstLine.getLength()<=offsets.posOffset;\r\n            negOffsetOverflow = offsets.negOffset > 0 && lastLine !== undefined && lastLine.getLength()<=offsets.negOffset;\r\n        }\r\n        if(concatShortestPath.shortestPath.length === 0){\r\n            throw Error(\"The remaining shortest path after trimming according to offsets is empty.\");\r\n        }\r\n    }\r\n}","import {locationTypeEnum} from \"./map/Enum\";\r\nimport LineDecoder from \"./coder/LineDecoder\";\r\n\r\nexport default class OpenLRDecoder {\r\n    // static decode(encoded,mapDataBase,decoderProperties){\r\n    //     let decoderProp = {};\r\n    //     let rangeIncreases = 0;\r\n    //     for(let k in decoderProperties){\r\n    //         if(decoderProperties.hasOwnProperty(k)){\r\n    //             decoderProp[k] = decoderProperties[k];\r\n    //         }\r\n    //     }\r\n    //     if(encoded.type === locationTypeEnum.LINE_LOCATION){\r\n    //         try {\r\n    //             return LineDecoder.decode(mapDataBase,encoded.LRPs,encoded.posOffset,encoded.negOffset,decoderProp);\r\n    //         }\r\n    //         catch(e){\r\n    //             if(!decoderProp.alwaysUseProjections){\r\n    //                 // if decoding fails without always using projections,\r\n    //                 // try again with always using projections\r\n    //                 decoderProp.alwaysUseProjections = true;\r\n    //                 return LineDecoder.decode(mapDataBase,encoded.LRPs,encoded.posOffset,encoded.negOffset,decoderProp);\r\n    //             }\r\n    //             else{\r\n    //                 while(rangeIncreases < decoderProp.maxDecodeRetries){\r\n    //                     rangeIncreases++;\r\n    //                     decoderProp.dist = decoderProp.dist * decoderProp.distMultiplierForRetry;\r\n    //                     decoderProp.distanceToNextDiff = decoderProp.distanceToNextDiff * decoderProp.distMultiplierForRetry;\r\n    //                     try {\r\n    //                         return LineDecoder.decode(mapDataBase,encoded.LRPs,encoded.posOffset,encoded.negOffset,decoderProp);\r\n    //                     }\r\n    //                     catch(err){\r\n    //                         if(rangeIncreases >= decoderProp.maxDecodeRetries){\r\n    //                             throw(err)\r\n    //                         }\r\n    //                     }\r\n    //                 }\r\n    //                 throw(e); //re-throw the error\r\n    //             }\r\n    //         }\r\n    //     }\r\n    // }\r\n    // //retry with bigger dist and use no proj and always proj each time\r\n    static decode(encoded,mapDataBase,decoderProperties){\r\n        let decoderProp = {};\r\n        let rangeIncreases = 0;\r\n        for(let k in decoderProperties){\r\n            if(decoderProperties.hasOwnProperty(k)){\r\n                decoderProp[k] = decoderProperties[k];\r\n            }\r\n        }\r\n        if(decoderProp.maxDecodeRetries === undefined){\r\n            decoderProp.maxDecodeRetries = 0;\r\n        }\r\n        if(encoded.type === locationTypeEnum.LINE_LOCATION){\r\n            while(rangeIncreases <= decoderProp.maxDecodeRetries){\r\n                try {\r\n                    return LineDecoder.decode(mapDataBase,encoded.LRPs,encoded.posOffset,encoded.negOffset,decoderProp);\r\n                }\r\n                catch(e){\r\n                    if(!decoderProp.alwaysUseProjections){\r\n                        // if decoding fails without always using projections,\r\n                        // try again with always using projections\r\n                        decoderProp.alwaysUseProjections = true;\r\n                    }\r\n                    else{\r\n                        if(decoderProp.dist && decoderProp.distMultiplierForRetry && decoderProp.distanceToNextDiff){\r\n                            rangeIncreases++;\r\n                            if(rangeIncreases > decoderProp.maxDecodeRetries){\r\n                                throw(e); //re-throw the error\r\n                            }\r\n                            let oldDist = decoderProp.dist;\r\n                            decoderProp.dist = decoderProp.dist * decoderProp.distMultiplierForRetry;\r\n                            decoderProp.distanceToNextDiff = decoderProp.distanceToNextDiff + (decoderProp.dist - oldDist) * 2;\r\n                            decoderProp.alwaysUseProjections = false;\r\n                        }\r\n                        else{\r\n                            throw(e); //re-throw the error\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // //no retry mechanism\r\n    // static decode(encoded,mapDataBase,decoderProperties){\r\n    //     let decoderProp = {};\r\n    //     for(let k in decoderProperties){\r\n    //         if(decoderProperties.hasOwnProperty(k)){\r\n    //             decoderProp[k] = decoderProperties[k];\r\n    //         }\r\n    //     }\r\n    //     if(encoded.type === locationTypeEnum.LINE_LOCATION){\r\n    //         return LineDecoder.decode(mapDataBase,encoded.LRPs,encoded.posOffset,encoded.negOffset,decoderProp);\r\n    //     }\r\n    // }\r\n}","import {configProperties} from \"./CoderSettings\";\r\n\r\nexport default class LocationReferencePoint{\r\n    constructor(bearing,distanceToNext,frc,fow,lfrcnp,islast,lat,lon,seqNr){\r\n        this.bearing = Math.round(bearing);\r\n        this.distanceToNext = Math.round(distanceToNext/configProperties.internalPrecision);\r\n        this.frc = frc;\r\n        this.fow = fow;\r\n        this.lfrcnp = lfrcnp;\r\n        this.isLast = islast;\r\n        this.lat = Number(Math.round(lat+'e5')+'e-5');\r\n        this.long = Number(Math.round(lon+'e5')+'e-5');\r\n        this.seqNr = seqNr;\r\n    }\r\n}","import LocationReferencePoint from \"./LocationReferencePoint\";\r\n// import {point} from '@turf/helpers'\r\n// import bearing from '@turf/bearing'\r\nimport {frcEnum} from \"../map/Enum\";\r\n// import {configProperties} from \"./CoderSettings\";\r\n\r\nexport default class LRPNodeHelper{\r\n\r\n    static lrpLinesToLRPs(lrpLines,shortestPaths){\r\n        if(lrpLines.length<2){\r\n            throw Error(\"not enough LRP lines\");\r\n        }\r\n        let LRPs = [];\r\n        for(let i=0;i<lrpLines.length;i++){\r\n            let properties = {};\r\n            let isLast = false;\r\n            let frc = lrpLines[i].getFRC();\r\n            let fow = lrpLines[i].getFOW();\r\n            let lat;\r\n            let long;\r\n            let distanceToNext;\r\n            let bearing;\r\n            let lfrcnp;\r\n            if(i < lrpLines.length-1){\r\n                properties = this.calcProperties(shortestPaths[i].lines,lrpLines[i+1].getStartNode());\r\n                lat = lrpLines[i].getStartNode().getLatitudeDeg();\r\n                long = lrpLines[i].getStartNode().getLongitudeDeg();\r\n                bearing = lrpLines[i].getBearing();\r\n                lfrcnp = properties.lfrcnp;\r\n                distanceToNext = lrpLines[i].getLength() + properties.pathLength;\r\n                if(i === lrpLines.length-2 && lrpLines[lrpLines.length-2].getID() !== lrpLines[lrpLines.length-1].getID()){\r\n                    distanceToNext+=lrpLines[lrpLines.length-1].getLength();\r\n                }\r\n            }\r\n            else{\r\n                isLast = true;\r\n                lat = lrpLines[i].getEndNode().getLatitudeDeg();\r\n                long = lrpLines[i].getEndNode().getLongitudeDeg();\r\n                bearing = lrpLines[i].getReverseBearing();\r\n                lfrcnp = frcEnum.FRC_7;\r\n                distanceToNext = 0;\r\n            }\r\n            let LRP = new LocationReferencePoint(\r\n                bearing,\r\n                distanceToNext,\r\n                frc,\r\n                fow,\r\n                lfrcnp,\r\n                isLast,\r\n                lat,\r\n                long,\r\n                i+1\r\n            );\r\n            LRPs.push(LRP);\r\n        }\r\n        return LRPs;\r\n    }\r\n\r\n    static calcProperties(shortestPath,nextNode){\r\n            let i = 0;\r\n            let pathLength = 0;\r\n            let leastFRCtillNextPoint = frcEnum.FRC_0;\r\n            let frcIsDefined = false;\r\n            while(i < shortestPath.length && shortestPath[i].getStartNode() !== nextNode){\r\n                pathLength += shortestPath[i].getLength();\r\n                if(shortestPath[i].getFRC() !== undefined && shortestPath[i].getFRC() > leastFRCtillNextPoint){\r\n                    leastFRCtillNextPoint = shortestPath[i].getFRC();\r\n                    frcIsDefined = true;\r\n                }\r\n                i++;\r\n            }\r\n            return {\r\n                pathLength: pathLength,\r\n                lfrcnp: frcIsDefined ? leastFRCtillNextPoint : frcEnum.FRC_7\r\n            }\r\n        }\r\n\r\n    /*\r\n    \" The bearing (BEAR) describes the angle between the true North and a line which is defined by the\r\n    coordinate of the LR-point and a coordinate which is BEARDIST along the line defined by the LR-point attributes.\r\n    If the line length is less than BEARDIST then the opposite point of the line is used\r\n    (regardless of BEARDIST). The bearing is measured in degrees and always positive (measuring\r\n    clockwise from North). \"\r\n    <- http://www.openlr.org/data/docs/OpenLR-Whitepaper_v1.5.pdf\r\n     */\r\n    // static calcProperties(beardist,node,shortestPath,nextNode){\r\n    //     //find the position beardist meters on the path, unless the next LRP is closer than 20 meters\r\n    //     let i = 0;\r\n    //     let pathLength = 0;\r\n    //     let calcBear = undefined;\r\n    //     let leastFRCtillNextPoint = frcEnum.FRC_7;\r\n    //     while(i < shortestPath.length && shortestPath[i].getStartNode() !== nextNode){\r\n    //         if(calcBear === undefined && pathLength+shortestPath[i].getLength() > 20){\r\n    //             // the bearingdist point lays on this line\r\n    //             let distanceFromLRP = beardist - pathLength;\r\n    //             let bearDistLoc = shortestPath[i].getGeoCoordinateAlongLine(distanceFromLRP);\r\n    //             let lrpPoint = point([node.getLatitudeDeg(), node.getLongitudeDeg()]);\r\n    //             let bearDistPoint = point([bearDistLoc.lat,bearDistLoc.long]);\r\n    //\r\n    //             calcBear = bearing(lrpPoint, bearDistPoint);\r\n    //             if(calcBear < 0){\r\n    //                 // bear is always positive, counterclockwise\r\n    //                 calcBear += 360;\r\n    //             }\r\n    //         }\r\n    //         pathLength += shortestPath[i].getLength();\r\n    //         if(shortestPath[i].getFRC() !== undefined && shortestPath[i].getFRC() < leastFRCtillNextPoint){\r\n    //             leastFRCtillNextPoint = shortestPath[i].getFRC();\r\n    //         }\r\n    //         i++;\r\n    //     }\r\n    //     if(calcBear === undefined){\r\n    //         //means that the next LRP lays earlier than the beardist point\r\n    //         let lrpPoint = point([node.getLatitudeDeg(), node.getLongitudeDeg()]);\r\n    //         let nextLrpPoint = point([nextNode.getLatitudeDeg(), nextNode.getLongitudeDeg()]);\r\n    //\r\n    //         calcBear = bearing(lrpPoint, nextLrpPoint);\r\n    //         if(calcBear < 0){\r\n    //             // bear is always positive, counterclockwise\r\n    //             calcBear += 360;\r\n    //         }\r\n    //     }\r\n    //     return {\r\n    //         bearing: calcBear,\r\n    //         pathLength: pathLength,\r\n    //         lfrcnp: leastFRCtillNextPoint\r\n    //     }\r\n    // }\r\n    //\r\n    // static calcLastLRPProperties(beardist,prevNode,shortestPath,lastNode){\r\n    //     //find the position beardist meters away from the end of the path, unless the previous LRP is closer than 20 meters\r\n    //     let i = 0;\r\n    //     let calcBear = undefined;\r\n    //     let leastFRCtillNextPoint = frcEnum.FRC_0;\r\n    //     while(i < shortestPath.length && shortestPath[i].getStartNode() !== lastNode){\r\n    //         if(shortestPath[i].getFRC() !== undefined && shortestPath[i].getFRC() < leastFRCtillNextPoint){\r\n    //             leastFRCtillNextPoint = shortestPath[i].getFRC();\r\n    //         }\r\n    //         i++;\r\n    //     }\r\n    //     i--;\r\n    //     let reverseLength = 0;\r\n    //     while(i > 0 && calcBear === undefined){\r\n    //         if(reverseLength+shortestPath[i].getLength() > beardist){\r\n    //             // the bearingdist point lays on this line\r\n    //             let distance = reverseLength+shortestPath[i].getLength()-beardist;\r\n    //             let bearDistLoc = shortestPath[i].getGeoCoordinateAlongLine(distance);\r\n    //             let lrpPoint = point([lastNode.getLatitudeDeg(), lastNode.getLongitudeDeg()]);\r\n    //             let bearDistPoint = point([bearDistLoc.lat,bearDistLoc.long]);\r\n    //\r\n    //             calcBear = bearing(lrpPoint, bearDistPoint);\r\n    //             if(calcBear < 0){\r\n    //                 // bear is always positive, counterclockwise\r\n    //                 calcBear += 360;\r\n    //             }\r\n    //         }\r\n    //         i--;\r\n    //     }\r\n    //     if(calcBear === undefined){\r\n    //         //means that the previous LRP lays further than the beardist point\r\n    //         let lrpPoint = point([lastNode.getLatitudeDeg(), lastNode.getLongitudeDeg()]);\r\n    //         let prevLrpPoint = point([prevNode.getLatitudeDeg(), prevNode.getLongitudeDeg()]);\r\n    //\r\n    //         calcBear = bearing(lrpPoint, prevLrpPoint);\r\n    //         if(calcBear < 0){\r\n    //             // bear is always positive, counterclockwise\r\n    //             calcBear += 360;\r\n    //         }\r\n    //     }\r\n    //\r\n    //     return {\r\n    //         bearing: calcBear,\r\n    //         pathLength: 0,\r\n    //         lfrcnp: leastFRCtillNextPoint\r\n    //     }\r\n    // }\r\n}","import Dijkstra from \"./Dijkstra\";\r\nimport {locationTypeEnum} from \"../map/Enum\";\r\nimport LRPNodeHelper from \"./LRPNodeHelper\";\r\nimport {configProperties} from \"./CoderSettings\";\r\n\r\nexport default class LineEncoder {\r\n    static encode(mapDataBase,linesToEncode,posOffset,negOffset){\r\n        let lines = linesToEncode.slice();\r\n        let lrpLines = [];\r\n        let shortestPaths = [];\r\n        let offsets = {\r\n            posOffset: Math.round(posOffset*configProperties.internalPrecision),\r\n            negOffset: Math.round(negOffset*configProperties.internalPrecision)\r\n        };\r\n\r\n        // 1: check validity of the location and offsets to be encoded\r\n        LineEncoder.checkValidityAndAdjustOffsets(lines,offsets);\r\n\r\n        // 2: adjust start and end nodes of the location to represent valid map nodes\r\n        let expanded = this.adjustToValidStartEnd(mapDataBase,lines,offsets); //lines[expanded.front] to lines[lines.length-1-expanded.back] can NOT be used, the full path should be used in SP calculation!!!\r\n        lrpLines.push(lines[0]);\r\n\r\n        // calculate length of the Lines in lines. This can serve as a maxDist value for the Dijkstra algorithm\r\n        // since a node further away than this dist will never be part of any the shortest path\r\n        let maxDist = 0;\r\n        for(let i=0;i<lines.length;i++){\r\n            maxDist += lines[i].getLength();\r\n        }\r\n\r\n        // 3: determine coverage of the location by a shortest-path\r\n        let shortestPath;\r\n        // 4: check whether the calculated shortest-path covers the location completely\r\n        let checkResult;\r\n        if(lines.length === 1){\r\n            //if there is only line, the sp calculation would return the line in the other direction of the given line (but wouldn't be used further in the algoritm\r\n            shortestPath = {\r\n                lines: [],\r\n                length: 0\r\n            };\r\n            checkResult = {\r\n                fullyCovered: true,\r\n                lrpIndexInSP: 1,\r\n                lrpIndexInLoc: 1\r\n            }\r\n        }\r\n        else{\r\n            shortestPath = Dijkstra.shortestPath(lines[0].getEndNode(),lines[lines.length-1].getStartNode(),{maxDist: maxDist});\r\n            checkResult = this.checkShortestPathCoverage(1,lines,shortestPath.lines,lines.length-1);\r\n        }\r\n        shortestPaths.push(shortestPath);\r\n\r\n        //location not completely covered, intermediate LRPs needed\r\n        LineEncoder.addLRPsUntilFullyCovered(checkResult,lines,lrpLines,shortestPaths,shortestPath);\r\n        // 7: concatenate the calculated shortest-paths for a complete coverage of the location and\r\n        // form an ordered list of location reference points (from the start to the end of the location)\r\n        let concatenatedSPResult = this.concatenateAndValidateShortestPaths(lrpLines,shortestPaths,offsets);\r\n        checkResult = this.checkShortestPathCoverage(0,lines,concatenatedSPResult.shortestPath,lines.length);\r\n        if(!checkResult.fullyCovered){\r\n            throw Error(\"something went wrong with determining the concatenated shortest path\");\r\n        }\r\n\r\n        // 8: check validity of the location reference path. If the location reference path is invalid then\r\n        // go to step 9, if the location reference path is valid, then go to step 10\r\n        while(!concatenatedSPResult.isValid){\r\n            // 9: add a sufficient number of additional intermediate location reference points if the\r\n            // distance between two location reference points exceeds the maximum distance.\r\n            // Remove the start/end LR-point if the positive/negative offset value exceeds the length\r\n            // of the corresponding path.\r\n            if(concatenatedSPResult.wrongPosOffset){\r\n                //remove LRP at the front\r\n                this.removeLRPatFront(lrpLines,shortestPaths,lines,offsets,concatenatedSPResult.distanceBetweenFirstTwo);\r\n                concatenatedSPResult = this.concatenateAndValidateShortestPaths(lrpLines,shortestPaths,offsets);\r\n            }\r\n            if(concatenatedSPResult.wrongNegOffset){\r\n                //remove LRP at the end\r\n                this.removeLRPatEnd(lrpLines,shortestPaths,lines,offsets,concatenatedSPResult.distanceBetweenLastTwo);\r\n                concatenatedSPResult = this.concatenateAndValidateShortestPaths(lrpLines,shortestPaths,offsets);\r\n            }\r\n            if(concatenatedSPResult.wrongIntermediateDistance){\r\n                //add intermediate LRPs\r\n                this.addIntermediateLRPs(lrpLines,shortestPaths,lines);\r\n                //todo\r\n                throw Error(\"not yet supported\");\r\n            }\r\n            //check if the location is still fully covered\r\n            checkResult = this.checkShortestPathCoverage(0,lines,concatenatedSPResult.shortestPath,lines.length);\r\n            if(!checkResult.fullyCovered){\r\n                throw Error(\"something went wrong while making the concatenated shortest path valid\");\r\n            }\r\n        }\r\n\r\n        // 10: create physical representation of the location reference (json)\r\n        let LRPs = LRPNodeHelper.lrpLinesToLRPs(lrpLines,shortestPaths);\r\n        return {\r\n            type:locationTypeEnum.LINE_LOCATION,\r\n            LRPs: LRPs,\r\n            posOffset: Math.round(offsets.posOffset/configProperties.internalPrecision),\r\n            negOffset: Math.round(offsets.negOffset/configProperties.internalPrecision)\r\n        };\r\n    }\r\n\r\n    static checkValidityAndAdjustOffsets(lines,offsets){\r\n        if(lines !== undefined && lines.length > 0){\r\n            let pathLength = lines[0].getLength();\r\n            let prevLineEndNode = lines[0].getEndNode();\r\n            let i=1;\r\n            while(i<lines.length && lines[i] !== undefined\r\n            && lines[i].getStartNode().getID() === prevLineEndNode.getID()){\r\n                prevLineEndNode = lines[i].getEndNode();\r\n                pathLength+=lines[i].getLength();\r\n                i++;\r\n                //todo: check if also traversable from start to end\r\n            }\r\n            if(i !== lines.length){\r\n                throw Error(\"line isn't a connected path\");\r\n            }\r\n            if(offsets.posOffset + offsets.negOffset >= pathLength){\r\n                throw Error(\"offsets longer than path: path=\"+pathLength+\" posOffset=\"+offsets.posOffset+ \" negOffset=\"+offsets.negOffset);\r\n            }\r\n            //remove unnecessary start or end lines\r\n            while(lines.length>0 && offsets.posOffset >= lines[0].getLength()){\r\n                console.log(\"first line should be omitted\");\r\n                offsets.posOffset -= lines[0].getLength();\r\n                lines.shift();\r\n            }\r\n            while(lines.length>0 && offsets.negOffset >= lines[lines.length-1].getLength()){\r\n                console.log(\"last line should be omitted\");\r\n                offsets.negOffset -= lines[lines.length-1].getLength();\r\n                lines.pop();\r\n            }\r\n            //todo vereisten voor binary formaat\r\n            //todo if(pathLength > 15km) ... happens in step 8\r\n        }\r\n    }\r\n\r\n    // if this step fails, the encoding can proceed to the next step\r\n    static adjustToValidStartEnd(mapDataBase,lines,offsets){\r\n        let expanded = {\r\n            front: 0,\r\n            back: 0\r\n        };\r\n\r\n        let pathLength = {length: 0};\r\n        lines.forEach(function (line) {\r\n           pathLength.length+=line.getLength();\r\n        });\r\n        // check if map has turn restrictions, detect invalid nodes according rule 4 of the whitepaper\r\n        if(!mapDataBase.hasTurnRestrictions() && !mapDataBase.hasTurnRestrictionOnPath(lines)){ //todo: why do we need to check this?\r\n            //node is invalid if\r\n            //one line enters and line leaves (note: lines are directed)\r\n            //two lines enter and two lines leave, but they are connected to only 2 adjacent nodes,\r\n            //unless a u-turn is possible at that node\r\n            if(lines[0] !== undefined && lines[lines.length-1] !== undefined){\r\n                //start node expansion\r\n                let originalStartLineId = lines[0].getID();\r\n                while(LineEncoder.nodeIsInValid(lines[0].getStartNode())\r\n                    && !(expanded.front > 0 && lines[0].getID() === originalStartLineId)) //detect an infinite start node expansion\r\n                {\r\n                    if(lines[0].getStartNode().getIncomingLines().length === 1){\r\n                        this.expand(lines[0].getStartNode().getIncomingLines()[0],lines,pathLength,offsets,true);\r\n                        expanded.front += 1;\r\n                    }\r\n                    else if(lines[0].getStartNode().getIncomingLines().length === 2){\r\n                        // one of the outgoing lines is the second line of the location, so expansion should happen in the other direction\r\n                        if(lines[0].getStartNode().getIncomingLines()[0].getStartNode().getID() === lines[0].getEndNode().getID()){\r\n                            //expand to the start node of the second incoming line\r\n                            this.expand(lines[0].getStartNode().getIncomingLines()[1],lines,pathLength,offsets,true);\r\n                            expanded.front += 1;\r\n                        }\r\n                        else if(lines[0].getStartNode().getIncomingLines()[1].getStartNode().getID() === lines[0].getEndNode().getID()){\r\n                            //expand to the start node of the first incoming line\r\n                            this.expand(lines[0].getStartNode().getIncomingLines()[0],lines,pathLength,offsets,true);\r\n                            expanded.front += 1;\r\n                        }\r\n                        else{\r\n                            console.log(\"something went wrong at determining the start node expansion node\");\r\n                        }\r\n                    }\r\n                    else{\r\n                        console.log(\"something went wrong with determining if expansion is needed\");\r\n                    }\r\n                }\r\n                if(expanded.front > 0 && lines[0].getID() === originalStartLineId){\r\n                    // the line lays on a loop without valid nodes, so the line has been expanded with all the lines of the loop\r\n                    // these added lines should be removed so only the original line remains\r\n                    LineEncoder.undoExpansion(lines,originalStartLineId,expanded,offsets,true);\r\n                }\r\n                let originalEndLineId = lines[lines.length-1].getID();\r\n                //end node expansion\r\n                while(LineEncoder.nodeIsInValid(lines[lines.length-1].getEndNode())\r\n                    && !(expanded.back > 0 && lines[lines.length-1].getID() === originalEndLineId)) // detect an infinite end node expansion\r\n                {\r\n                    if(lines[lines.length-1].getEndNode().getOutgoingLines().length === 1){\r\n                        this.expand(lines[lines.length-1].getEndNode().getOutgoingLines()[0],lines,pathLength,offsets,false);\r\n                        expanded.back += 1;\r\n                    }\r\n                    else if(lines[lines.length-1].getEndNode().getOutgoingLines().length === 2){\r\n                        // one of the incoming lines is the second-last line of the location, so expansion should happen in the other direction\r\n                        if(lines[lines.length-1].getEndNode().getOutgoingLines()[0].getEndNode().getID() === lines[lines.length-1].getStartNode().getID()){\r\n                            //expand to the start node of the second incoming line\r\n                            this.expand(lines[lines.length-1].getEndNode().getOutgoingLines()[1],lines,pathLength,offsets,false);\r\n                            expanded.back += 1;\r\n                        }\r\n                        else if(lines[lines.length-1].getEndNode().getOutgoingLines()[1].getEndNode().getID() === lines[lines.length-1].getStartNode().getID()){\r\n                            //expand to the start node of the first incoming line\r\n                            this.expand(lines[lines.length-1].getEndNode().getOutgoingLines()[0],lines,pathLength,offsets,false);\r\n                            expanded.back += 1;\r\n                        }\r\n                        else{\r\n                            console.log(\"something went wrong at determining the end node expansion node\");\r\n                        }\r\n                    }\r\n                    else{\r\n                        console.log(\"something went wrong with determining if expansion is needed\");\r\n                    }\r\n                }\r\n                if(expanded.back > 0 && lines[lines.length-1].getID() === originalEndLineId){\r\n                    // the line lays on a loop without valid nodes, so the line has been expanded with all the lines of the loop\r\n                    // these added lines should be removed so only the original line remains\r\n                    LineEncoder.undoExpansion(lines,originalEndLineId,expanded,offsets,false);\r\n                }\r\n            }\r\n        }\r\n        return expanded;\r\n        //todo what if there are turn restrictions?\r\n    }\r\n\r\n    static nodeIsInValid(node){\r\n        let oneInOneOut = (node.getIncomingLines().length === 1 && node.getOutgoingLines().length === 1);\r\n        let twoInTwoOut = (node.getIncomingLines().length === 2 && node.getOutgoingLines().length === 2);\r\n\r\n        let expansionNeeded = false;\r\n        if(oneInOneOut){\r\n            //if the incoming line starts from the same node as the outgoing line ends, this node has only one sibling (border node in our graph) and thus is a valid node\r\n            expansionNeeded = (node.getIncomingLines()[0].getStartNode().getID() !== node.getOutgoingLines()[0].getEndNode().getID());\r\n        }\r\n        else if(twoInTwoOut){\r\n            //todo: if a u-turn can be made at the node, the node should be valid: turn restrictions should be known, how to implement these?\r\n            let firstIncomingStartEqFirstOutgoingEnd = (node.getIncomingLines()[0].getStartNode().getID() === node.getOutgoingLines()[0].getEndNode().getID());\r\n            let secondIncomingStartEqFirstOutgoingEnd = (node.getIncomingLines()[1].getStartNode().getID() === node.getOutgoingLines()[0].getEndNode().getID());\r\n            let firstIncomingStartEqSecondOutgoingEnd = (node.getIncomingLines()[0].getStartNode().getID() === node.getOutgoingLines()[1].getEndNode().getID());\r\n            let secondIncomingStartEqSecondOutgoingEnd = (node.getIncomingLines()[1].getStartNode().getID() === node.getOutgoingLines()[1].getEndNode().getID());\r\n\r\n            expansionNeeded = ((firstIncomingStartEqFirstOutgoingEnd && secondIncomingStartEqSecondOutgoingEnd) || (firstIncomingStartEqSecondOutgoingEnd && secondIncomingStartEqFirstOutgoingEnd));\r\n        }\r\n\r\n        return expansionNeeded;\r\n    }\r\n\r\n    static expand(lineToAdd,lines,pathLength,offsets,positive){\r\n        if(pathLength.length + lineToAdd.getLength() < 15000*configProperties.internalPrecision){\r\n            pathLength.length += lineToAdd.getLength();\r\n            if(positive){\r\n                offsets.posOffset += lineToAdd.getLength();\r\n                lines.unshift(lineToAdd);\r\n            }\r\n            else{\r\n                offsets.negOffset += lineToAdd.getLength();\r\n                lines.push(lineToAdd);\r\n            }\r\n        }\r\n        else{\r\n            console.log(\"start node expansion aborted because path length exceeding 15000m\")\r\n        }\r\n    }\r\n\r\n    static undoExpansion(lines,originalLineId,expanded,offsets,positive){\r\n        if(positive){\r\n            if(lines[0].getID() === originalLineId){\r\n                // the first line should be the line with the same ID as originalLineId and will be shifted out first\r\n                offsets.posOffset -= lines[0].getLength();\r\n                expanded.front--;\r\n                lines.shift();\r\n            }\r\n            else{\r\n                throw Error(\"undoExpansion at start node called but was not needed\");\r\n            }\r\n            while(lines[0].getID() !== originalLineId){\r\n                offsets.posOffset -= lines[0].getLength();\r\n                expanded.front--;\r\n                lines.shift();\r\n            }\r\n            if(expanded.front < 0){\r\n                throw Error(\"Something went wrong during reversing the start node expansion.\")\r\n            }\r\n        }\r\n        else {\r\n            if(lines[lines.length-1].getID() === originalLineId){\r\n                // the last line should be the line with the same ID as originalLineId and will be popped of first\r\n                offsets.negOffset -= lines[lines.length-1].getLength();\r\n                expanded.back--;\r\n                lines.pop();\r\n            }\r\n            else{\r\n                throw Error(\"undoExpansion at end node called but was not needed\");\r\n            }\r\n            while(lines[lines.length-1].getID() !== originalLineId){\r\n                offsets.negOffset -= lines[lines.length-1].getLength();\r\n                expanded.back--;\r\n                lines.pop();\r\n            }\r\n            if(expanded.back < 0){\r\n                throw Error(\"Something went wrong during reversing the end node expansion.\")\r\n            }\r\n        }\r\n    }\r\n\r\n    static checkShortestPathCoverage(lStartIndex,lines,shortestPath,lEndIndex){ //lEndIndex is one greater than the last index to be checked (confer length of an array)\r\n        if(lStartIndex === undefined || lines === undefined || shortestPath === undefined || lEndIndex === undefined){\r\n            throw Error(\"One of the parameters is undefined.\");\r\n        }\r\n        if(lEndIndex>lines.length){\r\n            throw Error(\"lEndIndex can't be greater than lines.length\");\r\n        }\r\n        else if(lStartIndex > lEndIndex){\r\n            throw Error(\"lStartIndex can't be greater than lEndIndex\");\r\n        }\r\n        let spIndex = 0;\r\n        let lIndex = lStartIndex;\r\n\r\n        if(lStartIndex === lEndIndex-1 && shortestPath.length  === 0){\r\n            return {\r\n                fullyCovered: true,\r\n                lrpIndexInSP: spIndex,\r\n                lrpIndexInLoc: lIndex+1\r\n            }\r\n        }\r\n        else {\r\n            while (lIndex < lEndIndex && spIndex < shortestPath.length\r\n                && lines[lIndex].getID() === shortestPath[spIndex].getID()\r\n                ) {\r\n                spIndex++;\r\n                lIndex++;\r\n            }\r\n            //if even the first line of the shortest path is not correct, a new LRP (lines[lStartIndex].getStartNode()) should be added that has the lines[lStartIndex] as outgoing line\r\n            //if only the first line of the shortest path is correct, the next line lines[lStartIndex+1] should start in a new LRP\r\n            //so lrpIndexInLoc indicates the index of the line of which the startnode should be a new LRP, because that is the line that didn't match the shortest path\r\n            if (lIndex === lEndIndex && spIndex + lStartIndex === lIndex) {\r\n                return {\r\n                    fullyCovered: true,\r\n                    lrpIndexInSP: spIndex,\r\n                    lrpIndexInLoc: lIndex\r\n                }\r\n            }\r\n            else {\r\n                return {\r\n                    fullyCovered: false,\r\n                    lrpIndexInSP: spIndex,\r\n                    lrpIndexInLoc: lIndex\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    static addLRPsUntilFullyCovered(prevCheckResult,lines,lrpLines,shortestPaths,prevShortestPath){\r\n        let checkResult = prevCheckResult;\r\n        let shortestPath = prevShortestPath;\r\n        while(! checkResult.fullyCovered){\r\n            //calculate the length of the location that should be covered, this can be used to speed up the Dijkstra algorithm\r\n            let maxDist = 0;\r\n            for(let i=checkResult.lrpIndexInLoc+1;i<lines.length-1;i++){\r\n                maxDist += lines[i].getLength();\r\n            }\r\n            // 5: Determine the position of a new intermediate location reference point so that the part of\r\n            // the location between the start of the shortest-path calculation and the new intermediate\r\n            // is covered completely by a shortest-path.\r\n            if(!this.nodeIsInValid(lines[checkResult.lrpIndexInLoc].getStartNode())){\r\n                // the node is valid, this means that the shortest path would follow the location reference up until the point of lrpIndexInLoc\r\n                // this point of lrpIndexInLoc can be made into a new LRP\r\n                lrpLines.push(lines[checkResult.lrpIndexInLoc]);\r\n                // 6: go to step 3 and restart shortest path calculation between the new intermediate location\r\n                // reference point and the end of the location\r\n                shortestPath = Dijkstra.shortestPath(lines[checkResult.lrpIndexInLoc].getEndNode(),lines[lines.length-1].getStartNode(),{maxDist: maxDist});\r\n                shortestPaths.push(shortestPath);\r\n                checkResult = this.checkShortestPathCoverage(checkResult.lrpIndexInLoc+1,lines,shortestPath.lines,lines.length-1);\r\n            }\r\n            else{\r\n                // this can happen if the path between two LRPs contains invalid nodes, but there exist a route in the other direction\r\n                // that forms a loop between these LRPs and provides a shorter path.\r\n                // so while the path can't change in an invalid node, a U-turn can be made because the way in the other direction is still shorter\r\n                // we will search for valid nodes on the path to encode that can function as LRPs\r\n                // if no valid nodes can be found, invalid nodes must be used instead\r\n                if(checkResult.lrpIndexInSP !== 0){\r\n                    // this means that the shortest path should have no line in common with the lines to encode between te LRPs\r\n                    // if some lines should overlap, it would mean that a point exists were the shortest path and the lines to encode can take another route\r\n                    // which would mean that that point would be a valid node and we would not be in the first part of this if else structure\r\n                    throw Error(\"Something went wrong during the covering of the location with shortest paths. The location contains a part of a loop with invalid nodes\" +\r\n                        \" but the shortest path diverges on this part which would imply the existence of a valid node on this part, which is not possible.\")\r\n                }\r\n                // since the shortest path doesn't have any lines in common with the location, it shouldn't have been pushed on the shortestPaths array\r\n                shortestPaths.pop();\r\n\r\n                // try to find a valid node on the shortest path that leads to the invalid node !!wrong\r\n                // let validNodeResult = this.findValidNodeOnSP(shortestPath.lines,checkResult.lrpIndexInSP); // wrong function/not needed/never needed since the SP doesn't cover the lines to encode at any point\r\n                // we could add the next line to encode as a LRP. This line does start in an invalid node.\r\n                // lrpLines.push(lines[checkResult.lrpIndexInLoc]);\r\n                // we know there are now more valid nodes on the lines to the next LRP, so we can try to only add 1 invalid LRP by counting the line length to the next LRP\r\n                // and since we know the length of the shortest path, we have to make sure that the line length to the invalid LRP + the length of the shortest path is longer than\r\n                // is bigger than the distance from the invalid LRP to the next LRP. That way, the next shortest path between the invalid LRP and the next LRP wil never return on it's way\r\n                // and will guaranteed cover the lines between the invalid LRP and the next LRP.\r\n                // since the list of lines and the wrong shortest path create a loop, we also have to make sure that the length of the path to the chosen invalid LRP is smaller than\r\n                // the length of the wrong shortest path + the length of the lines between the invalid LRP and the next LRP, because otherwise the wrong shortest path will be the shortest path to this invalid LRP\r\n                // for this we do need to know what next LRP, which can simply be the next valid node that is present in the list of lines. If there is no valid node in the list of lines,\r\n                // because even the last node was invalid (because the network is an infinite loop of invalid nodes), the last node will always function as an LRP.\r\n\r\n\r\n                checkResult = LineEncoder.findInvalidNodeOnLinesAfterACertainLength(lines,checkResult.lrpIndexInLoc,shortestPath.length,lrpLines,shortestPaths,maxDist);\r\n            }\r\n        }\r\n\r\n        // push the last line of the expanded location to the list of LRPs,\r\n        // even if the expanded location contains only one line: in that case lrpLines contains the line two times\r\n        lrpLines.push(lines[lines.length-1]);\r\n    }\r\n\r\n    static findInvalidNodeOnLinesAfterACertainLength(lines,lrpIndexInLoc,shortestPathLength,lrpLines,shortestPaths,maxDist){\r\n        //todo: not al different cases are tested in unit tests\r\n        let nextValidNode = LineEncoder.findNextValidNode(lines,lrpIndexInLoc);\r\n        let nextValidIndex = nextValidNode.nextValidStartNodeIndexInLoc === undefined ? lines.length-1 : nextValidNode.nextValidStartNodeIndexInLoc;\r\n\r\n        if(nextValidIndex !== lines.length-1){\r\n            // there is still a valid node on the location between the current LRP and the last LRP\r\n            let lengthFromLRPToNextLRP =  nextValidNode.restLengthOfLines - nextValidNode.lengthToIndex;\r\n            if(nextValidNode.lengthToIndex-shortestPathLength < lengthFromLRPToNextLRP){\r\n                //the shortest path to this valid location doesn't follow the wrong shortest path to the end LRP\r\n                shortestPaths.push(nextValidNode.spToValidNode);\r\n                lrpLines.push(lines[nextValidIndex]);\r\n                let shortestPath = Dijkstra.shortestPath(lines[nextValidIndex].getEndNode(),lines[lines.length-1].getStartNode(),{maxDist: maxDist});\r\n                shortestPaths.push(shortestPath);\r\n                return this.checkShortestPathCoverage(nextValidIndex,lines,shortestPath.lines,lines.length-1);\r\n            }\r\n        }\r\n        else {\r\n            // there is no valid node on the location between the current LRP and the last LRP,\r\n            // or there is a valid node, but it doesn't lay in the correct interval\r\n            let lengthToLRP = lines[lrpIndexInLoc].getLength();\r\n            let spLines = [lines[lrpIndexInLoc]];\r\n            let i=lrpIndexInLoc+1;\r\n            let invalidLRPAdded = false;\r\n            while(i<nextValidIndex && !invalidLRPAdded){\r\n                let lengthFromLRPToNextLRP =  nextValidNode.restLengthOfLines -lengthToLRP;\r\n                if(lengthToLRP+shortestPathLength > lengthFromLRPToNextLRP && lengthToLRP-shortestPathLength < lengthFromLRPToNextLRP){\r\n                    // this line lays on the loop of invalid nodes, at a position were the wrong shortest path would never be\r\n                    // taken as part of a shortest path calculation to this line, and the wrong shortest path would never be taken\r\n                    // as part of a shortest path calculation from this line to the next LRP\r\n                    lrpLines.push(lines[i]);\r\n                    shortestPaths.push({\r\n                        length: lengthToLRP,\r\n                        lines: spLines\r\n                    });\r\n                    invalidLRPAdded = true;\r\n                    spLines = [];\r\n                    lengthToLRP = 0;\r\n                }\r\n                if(!invalidLRPAdded){\r\n                    lengthToLRP += lines[i].getLength();\r\n                    spLines.push(lines[i]);\r\n                }\r\n                i++;\r\n            }\r\n            if(invalidLRPAdded){\r\n                // we added an invalid LRP in the previous while loop, we can loop over the remaining lines to form the shortest path\r\n                // to the next valid LRP and push this on the shortestPaths array\r\n                while(i<nextValidIndex){\r\n                    lengthToLRP += lines[i].getLength();\r\n                    spLines.push(lines[i]);\r\n                    i++;\r\n                }\r\n                shortestPaths.push({\r\n                    length: lengthToLRP,\r\n                    lines: spLines\r\n                });\r\n                if(nextValidIndex === lines.length-1){\r\n                    // the full location to the last line is covered\r\n                    return {\r\n                        fullyCovered: true,\r\n                        lrpIndexInSP: spLines.length-1,\r\n                        lrpIndexInLoc: i\r\n                    }\r\n                }\r\n                else{\r\n                    // we should add the next valid LRP and check if the location is covered\r\n                    let shortestPath = Dijkstra.shortestPath(lines[nextValidIndex].getEndNode(),lines[lines.length-1].getStartNode(),{maxDist: maxDist});\r\n                    shortestPaths.push(shortestPath);\r\n                    return this.checkShortestPathCoverage(nextValidIndex,lines,shortestPath.lines,lines.length-1);\r\n                }\r\n            }\r\n            else{\r\n                // there is no valid or invalid LRP possible in the given distance interval\r\n                // so we simply convert the second line in the list of lines to an lrpLine (starts in an invalid Node)\r\n                // since the first Line is a straight Line, adjacent to the last LRP, the shortest path to the beginning of second Line can not deviate from this first Line\r\n                // there always will be a second Line, otherwise an intermediate LRP wasn't needed because the last LRP and the first Line would already cover the location\r\n                lrpLines.push(lines[lrpIndexInLoc+1]);\r\n                shortestPaths.push({\r\n                    length: lines[lrpIndexInLoc].getLength(),\r\n                    lines: [lines[lrpIndexInLoc]]\r\n                });\r\n                let shortestPath = Dijkstra.shortestPath(lines[lrpIndexInLoc+1].getEndNode(),lines[lines.length-1].getStartNode(),{maxDist: maxDist});\r\n                shortestPaths.push(shortestPath);\r\n                return this.checkShortestPathCoverage(lrpIndexInLoc+1,lines,shortestPath.lines,lines.length-1);\r\n            }\r\n        }\r\n    }\r\n\r\n    static findNextValidNode(lines,lrpIndexInLoc){\r\n        // the startnode of lines[lrpIndexInLoc] will be invalid, otherwise this function wouldn't be called\r\n        let nextValidStartNodeIndexInLoc = undefined;\r\n        let lengthOfLines = lines[lrpIndexInLoc].getLength();\r\n        let lengthToIndex = undefined;\r\n        let spLinesToValidNode = [lines[lrpIndexInLoc]];\r\n        let spToValidNode = {};\r\n        let i = lrpIndexInLoc+1;\r\n        while(i<lines.length){\r\n            if(nextValidStartNodeIndexInLoc === undefined && !LineEncoder.nodeIsInValid(lines[i].getStartNode())){\r\n                nextValidStartNodeIndexInLoc = i;\r\n                lengthToIndex = lengthOfLines;\r\n                spToValidNode = {lines: spLinesToValidNode, length: lengthToIndex};\r\n            }\r\n            spLinesToValidNode.push(lines[i]);\r\n            lengthOfLines += lines[i].getLength();\r\n            i++;\r\n        }\r\n        return {\r\n            nextValidStartNodeIndexInLoc: nextValidStartNodeIndexInLoc,\r\n            lengthToIndex: lengthToIndex,\r\n            restLengthOfLines: lengthOfLines,\r\n            spToValidNode: spToValidNode\r\n        }\r\n    }\r\n\r\n    static concatenateAndValidateShortestPaths(lrpLines,shortestPaths,offsets){\r\n        if(lrpLines === undefined || shortestPaths === undefined || offsets === undefined){\r\n            throw Error(\"Parameters can not be undefined\");\r\n        }\r\n        let isValid = true;\r\n        let distanceBetweenFirstTwoLength = lrpLines[0].getLength();\r\n        let distanceBetweenLastTwoLength = lrpLines[lrpLines.length-1].getLength();\r\n        let wrongPosOffset = false;\r\n        let wrongNegOffset = false;\r\n        let wrongIntermediateOffset = false;\r\n\r\n        if(lrpLines.length-1 === shortestPaths.length){\r\n            let shortestPath = [];\r\n            if(lrpLines.length === 2 && lrpLines[0].getID() === lrpLines[1].getID()){\r\n                // lines contains only one line, so the first 2 lines in lrpLines are the same\r\n                // the second lrp line should not be pushed on the shortestPath\r\n                shortestPath.push(lrpLines[0]);\r\n            }\r\n            else{\r\n                for(let i=0;i<shortestPaths.length;i++){\r\n                    shortestPath.push(lrpLines[i]);\r\n                    if(i === shortestPaths.length-1){\r\n                        distanceBetweenLastTwoLength += lrpLines[i].getLength();\r\n                    }\r\n                    let a = 0;\r\n                    let lengthBetweenLRPs = lrpLines[i].getLength();\r\n                    //while the start node of a line is not the next LRP node, this line can be added\r\n                    //otherwise we should add the lines of the shortest path of that LRP node\r\n                    while(shortestPaths[i].lines !== undefined && shortestPaths[i].lines[a] !== undefined && shortestPaths[i].lines[a].getStartNode().getID() !== lrpLines[i+1].getStartNode().getID()){\r\n                        shortestPath.push(shortestPaths[i].lines[a]);\r\n                        lengthBetweenLRPs += shortestPaths[i].lines[a].getLength();\r\n                        if(i===0){\r\n                            distanceBetweenFirstTwoLength += shortestPaths[i].lines[a].getLength();\r\n                        }\r\n                        if(i===shortestPaths.length-1){\r\n                            distanceBetweenLastTwoLength += shortestPaths[i].lines[a].getLength();\r\n                        }\r\n                        a++;\r\n                    }\r\n                    if(lengthBetweenLRPs >= 15000*configProperties.internalPrecision){\r\n                        isValid = false;\r\n                        wrongIntermediateOffset = true;\r\n                    }\r\n                }\r\n                shortestPath.push(lrpLines[lrpLines.length-1]); //add the line incoming in the last LRP\r\n                if(lrpLines.length === 2){\r\n                    distanceBetweenFirstTwoLength += lrpLines[lrpLines.length-1].getLength();\r\n                }\r\n            }\r\n            if(distanceBetweenFirstTwoLength >=  15000*configProperties.internalPrecision || distanceBetweenLastTwoLength >= 15000*configProperties.internalPrecision){\r\n                isValid = false;\r\n                wrongIntermediateOffset = true;\r\n            }\r\n            //check if offset values are shorter then the distance between the first two/last two location reference points\r\n            if(offsets.posOffset >= distanceBetweenFirstTwoLength){\r\n                // can happen if we added extra intermediate LRPs on invalid nodes\r\n                isValid = false;\r\n                wrongPosOffset = true;\r\n            }\r\n            else if(offsets.negOffset >= distanceBetweenLastTwoLength){\r\n                // can happen if we added extra intermediate LRPs on invalid nodes\r\n                isValid = false;\r\n                wrongNegOffset = true;\r\n            }\r\n            return {\r\n                shortestPath: shortestPath,\r\n                isValid: isValid,\r\n                wrongPosOffset: wrongPosOffset,\r\n                wrongNegOffset: wrongNegOffset,\r\n                wrongIntermediateDistance: wrongIntermediateOffset,\r\n                distanceBetweenFirstTwo: distanceBetweenFirstTwoLength,\r\n                distanceBetweenLastTwo: distanceBetweenLastTwoLength\r\n            }\r\n        }\r\n        else{\r\n            throw Error(\"the amount of shortest paths is not one less than the amount of lrp nodes\");\r\n        }\r\n    }\r\n\r\n    static removeLRPatFront(lrpLines,shortestPaths,lines,offsets,length){\r\n        if(lrpLines.length > 0\r\n            && offsets.posOffset>=length\r\n        ){\r\n            offsets.posOffset -= length;\r\n            lrpLines.shift();\r\n            shortestPaths.shift();\r\n            while(lines[0].getID() !== lrpLines[0].getID()){\r\n                lines.shift();\r\n            }\r\n        }\r\n        else{\r\n            throw Error(\"unnecessary removing of LRP at front\");\r\n        }\r\n    }\r\n\r\n    static removeLRPatEnd(lrpLines,shortestPaths,lines,offsets,length){\r\n        if(lrpLines.length > 0\r\n            && offsets.negOffset>=length\r\n        ){\r\n            offsets.negOffset -= length;\r\n            lrpLines.pop();\r\n            shortestPaths.pop();\r\n            while(lines[lines.length-1].getID() !== lrpLines[lrpLines.length-1].getID()){\r\n                lines.pop();\r\n            }\r\n        }\r\n        else{\r\n            throw Error(\"unnecessary removing of LRP at end\");\r\n        }\r\n    }\r\n\r\n    static addIntermediateLRPs(lrpLines,shortestPaths,lines){\r\n        //todo\r\n        console.warn(\"todo addIntermediateLRPs\");\r\n    }\r\n}","import geojsonrdbush from 'geojson-rbush'\r\nimport {polygon} from '@turf/helpers'\r\n\r\nexport default class GeoJSONRbushSearchTree{\r\n    constructor(){\r\n        this.tree = geojsonrdbush();\r\n    }\r\n\r\n    addData(data){\r\n        this.tree.load(data);\r\n    }\r\n\r\n    //todo: remove data\r\n\r\n    //dist given in meters\r\n    //uses an approximate square bounding box around the given point, so it is possible that nodes/lines/data are returned that\r\n    //are further than dist away. It is still necessary to iterate the returned nodes/lines/data and calculate their real distance.\r\n    findCloseBy(lat,long,dist){\r\n        let earthRadius = 6371000;\r\n        let latDiff = this.toDegrees(dist/earthRadius);\r\n        let longDiff = this.toDegrees(dist/(Math.cos(this.toRadians(lat)) * earthRadius));\r\n        let latUpper = lat+latDiff;\r\n        let latLower = lat-latDiff;\r\n        let longUpper = long+longDiff;\r\n        let longLower = long-longDiff;\r\n        let p = polygon([[[longLower,latLower],[longLower,latUpper],[longUpper,latUpper],[longUpper,latLower],[longLower,latLower]]]);\r\n        let r = this.tree.search(p);\r\n        return r.features;\r\n    }\r\n\r\n    toRadians(degrees){\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    toDegrees(radians){\r\n        return radians / Math.PI * 180\r\n    }\r\n}","import {point} from '@turf/helpers'\r\nimport GeoJSONRbushSearchTree from \"./GeoJSONRbushSearchTree\";\r\n\r\nexport default class GeoJSONRbushNodeSearchTree extends GeoJSONRbushSearchTree{\r\n    constructor(nodes){\r\n        super();\r\n        this.addNodes(nodes);\r\n    }\r\n\r\n    // one node === Node object\r\n    addNodes(nodes){\r\n        let data = [];\r\n\r\n        //todo: maybe this could already be made in the openlr integration classes to speed te initialisation up\r\n        for(let id in nodes){\r\n            if(nodes.hasOwnProperty(id)){\r\n                if(isNaN(nodes[id].getLongitudeDeg()) || isNaN(nodes[id].getLatitudeDeg())){\r\n                    throw nodes[id];\r\n                }\r\n                let p = point([nodes[id].getLongitudeDeg(),nodes[id].getLatitudeDeg()],{id: id});\r\n                data.push(p);\r\n            }\r\n        }\r\n        this.tree.load(data);\r\n    }\r\n\r\n    //todo: remove nodes\r\n}","import {lineString} from '@turf/helpers'\r\nimport GeoJSONRbushSearchTree from \"./GeoJSONRbushSearchTree\";\r\n\r\nexport default class RbushLineSearchTree extends GeoJSONRbushSearchTree{\r\n    constructor(lines){\r\n        super();\r\n        this.addLines(lines);\r\n    }\r\n\r\n    //one line === Line object\r\n    addLines(lines){\r\n        let data = [];\r\n\r\n        //todo: maybe this could already be made in the openlr integration classes to speed this up\r\n        for(let id in lines){\r\n            if(lines.hasOwnProperty(id)){\r\n                if(lines[id].getStartNode() === undefined || lines[id].getEndNode() === undefined){\r\n                    throw lines[id];\r\n                }\r\n                data.push(lineString([\r\n                    [lines[id].getStartNode().getLongitudeDeg(),lines[id].getStartNode().getLatitudeDeg()],\r\n                    [lines[id].getEndNode().getLongitudeDeg(),lines[id].getEndNode().getLatitudeDeg()]\r\n                ],{id: id}));\r\n            }\r\n        }\r\n        this.tree.load(data);\r\n    }\r\n\r\n    //todo: remove lines\r\n}","import GeoJSONRbushNodeSearchTree from '../SearchTree/GeoJSONRbushNodeSearchTree';\r\nimport GeoJSONRbushLineSearchTree from \"../SearchTree/GeoJSONRbushLineSearchTree\";\r\nimport {configProperties} from \"../coder/CoderSettings\";\r\n\r\nexport default class MapDataBase {\r\n    constructor(\r\n        lines = {},\r\n        nodes = {},\r\n        boundingBox = {\r\n            left: undefined,\r\n            top: undefined,\r\n            right: undefined,\r\n            bottom: undefined\r\n        },\r\n        turnRestrictions = false\r\n    ) {\r\n        this.turnResctrictions = turnRestrictions;\r\n        this.mapBoundingBox = boundingBox;\r\n        this.lines = lines;\r\n        this.nodes = nodes;\r\n        this.nodeSearchTree = new GeoJSONRbushNodeSearchTree(nodes);\r\n        this.lineSearchTree = new GeoJSONRbushLineSearchTree(lines);\r\n        this.internalPrecision = configProperties.internalPrecision;\r\n    }\r\n\r\n    setData(\r\n        lines={},nodes={},boundingBox = {\r\n            left: undefined,\r\n            top: undefined,\r\n            right: undefined,\r\n            bottom: undefined\r\n        },turnRestrictions = false\r\n    )\r\n    {\r\n        this.turnResctrictions = turnRestrictions;\r\n        this.mapBoundingBox = boundingBox;\r\n        this.lines = lines;\r\n        this.nodes = nodes;\r\n        this.nodeSearchTree = new GeoJSONRbushNodeSearchTree(nodes);\r\n        this.lineSearchTree = new GeoJSONRbushLineSearchTree(lines);\r\n    }\r\n\r\n    hasTurnRestrictions(){\r\n        return this.turnResctrictions;\r\n    }\r\n\r\n    getLine(id){\r\n        return this.lines[id];\r\n    }\r\n\r\n    getNode(id){\r\n        return this.nodes[id];\r\n    }\r\n\r\n    findNodesCloseByCoordinate(lat,long,dist){\r\n        let resNodes = [];\r\n        let range = Math.round(dist/this.internalPrecision);\r\n        let possibleNodes = this.nodeSearchTree.findCloseBy(lat,long,range);\r\n        possibleNodes.forEach((node)=>{\r\n            let distance = this.nodes[node.properties.id].getDistance(lat,long);\r\n            if(distance <= dist){\r\n                resNodes.push({node: this.nodes[node.properties.id], dist: distance})\r\n            }\r\n        });\r\n        return resNodes;\r\n    }\r\n\r\n    findLinesCloseByCoordinate(lat,long,dist){\r\n        let resLines = [];\r\n        let range = Math.round(dist/this.internalPrecision);\r\n        let possibleLines = this.lineSearchTree.findCloseBy(lat,long,range);\r\n        possibleLines.forEach((line)=>{\r\n            let distance = this.lines[line.properties.id].distanceToPoint(lat,long);\r\n            if(distance <= dist){\r\n                resLines.push({line: this.lines[line.properties.id], dist: distance})\r\n            }\r\n        });\r\n        return resLines;\r\n    }\r\n\r\n    hasTurnRestrictionOnPath(lineList){\r\n        //todo: how to implement turn restrictions? is it a property of nodes or of lines or both?\r\n        if(!this.turnResctrictions){\r\n            //if database has no turn restrictions, a line should also have no turn restrictions\r\n            return this.turnResctrictions;\r\n        }\r\n        //https://wiki.openstreetmap.org/wiki/Relation:restriction\r\n        let i=0;\r\n        while(i<lineList.length && lineList[i].getTurnRestriction() !== undefined){\r\n            i++;\r\n        }\r\n        return i === lineList.length;\r\n    }\r\n\r\n    getAllNodes(){\r\n        return this.nodes;\r\n    }\r\n\r\n    getAllLines(){\r\n        return this.lines;\r\n    }\r\n\r\n    getMapBoundingBox(){\r\n        return this.mapBoundingBox;\r\n    }\r\n\r\n    getNumberOfNodes(){\r\n        return this.numberOfNodes;\r\n    }\r\n\r\n    getNumberOfLines(){\r\n        return this.numberOfLines;\r\n    }\r\n\r\n\r\n    addData(lines={},nodes={},boundingBox = {\r\n        left: undefined,\r\n        top: undefined,\r\n        right: undefined,\r\n        bottom: undefined\r\n    }){\r\n        //todo: speed this up\r\n        //maybe change lines and nodes to not contain references, but only ids\r\n        let nodesAdded = {};\r\n        let linesAdded = {};\r\n        for(let key in nodes){\r\n            if(nodes.hasOwnProperty(key)){\r\n                if(this.nodes[key]===undefined){\r\n                    //this node was not yet present\r\n                    this.nodes[key] = nodes[key];\r\n                    nodesAdded[key]=nodes[key];\r\n                }\r\n            }\r\n        }\r\n        for(let key in lines){\r\n            if(lines.hasOwnProperty(key)){\r\n                if(this.lines[key]===undefined){\r\n                    //this line was not yet present\r\n                    lines[key].startNode = this.nodes[lines[key].getStartNode().getID()];\r\n                    if(nodesAdded[lines[key].getStartNode().getID()] === undefined){\r\n                        // if this node wasn't just added, this node was already present, so the line should still\r\n                        // be added to it's outgoing lines\r\n                        this.nodes[lines[key].getStartNode().getID()].outgoingLines.push(lines[key]);\r\n                    }\r\n                    lines[key].endNode = this.nodes[lines[key].getEndNode().getID()];\r\n                    if(nodesAdded[lines[key].getEndNode().getID()] === undefined){\r\n                        // if this node wasn't just added, this node was already present, so the line should still\r\n                        // be added to it's incoming lines\r\n                        this.nodes[lines[key].getEndNode().getID()].incomingLines.push(lines[key]);\r\n                    }\r\n                    this.lines[lines[key].getID()] = lines[key];\r\n                    linesAdded[key]=lines[key];\r\n                }\r\n            }\r\n        }\r\n        this.nodeSearchTree.addNodes(nodesAdded);\r\n        this.lineSearchTree.addLines(linesAdded);\r\n        //todo: adjust bounding box\r\n    }\r\n\r\n    //todo: remove data\r\n}","import Line from \"../OpenLR/map/Line\";\r\nimport Node from \"../OpenLR/map/Node\";\r\nimport {fowEnum, frcEnum} from \"../OpenLR/map/Enum\";\r\nimport {OsmFowHighwayMapping} from \"./FOWmappings/OsmFowHighwayMapping\";\r\nimport {OsmFrcHighwayMapping} from \"./FRCmappings/OsmFrcHighwayMapping\";\r\n\r\nexport default class RoutableTilesIntegration{\r\n    static initMapDataBase(mapDataBase,nodes,ways,relations){\r\n        let nodesLines = RoutableTilesIntegration.getNodesLines(nodes,ways,relations);\r\n        mapDataBase.setData(nodesLines.lines,nodesLines.nodes); //todo: set bounding box\r\n    }\r\n\r\n    static getNodesLines(nodes,ways,relations){ //todo: use relations?\r\n        let openLRLines = {};\r\n        let openLRNodes = {};\r\n        let osmNodes = {};\r\n        let refToNodeId = {};\r\n        for(let id in nodes){\r\n            if(nodes.hasOwnProperty(id)){\r\n                let openLRNode = new Node(id,nodes[id].lat,nodes[id].long);\r\n                osmNodes[openLRNode.getID()] = openLRNode;\r\n                for(let i=0;i<nodes[id].ref.length;i++){\r\n                    refToNodeId[nodes[id].ref[i]] = nodes[id].id;\r\n                }\r\n            }\r\n        }\r\n        for(let id in ways){\r\n            if(ways.hasOwnProperty(id)){\r\n                for(let i =0;i<ways[id].nodes.length-1;i++){\r\n                    // if(ways[id].highway !== undefined){ //todo: should we filter on highway data?\r\n                        // add a line from this node to the next one\r\n                        // the id of the line is created out of the id of the way + underscore + id of the start node (since these lines aren't directly identified in RoutableTiles)\r\n                        let openLRLine = new Line(id+\"_\"+refToNodeId[ways[id].nodes[i]],osmNodes[refToNodeId[ways[id].nodes[i]]],osmNodes[refToNodeId[ways[id].nodes[i+1]]]);\r\n                        openLRLine.frc = RoutableTilesIntegration.getFRC(ways[id]);\r\n                        openLRLine.fow = RoutableTilesIntegration.getFOW(ways[id]);\r\n                        openLRLines[openLRLine.getID()] = openLRLine;\r\n                        if(ways[id].oneway === undefined || ways[id].oneway === \"osm:no\"){\r\n                            // since OSM doesn't have directed lines for it's roads, we will add the line in the other direction, so it is always present both as an input line and an output line in a node\r\n                            let reverseOpenLRLine = new Line(id+\"_\"+refToNodeId[ways[id].nodes[i]]+\"_1\",osmNodes[refToNodeId[ways[id].nodes[i+1]]],osmNodes[refToNodeId[ways[id].nodes[i]]]);\r\n                            reverseOpenLRLine.frc = RoutableTilesIntegration.getFRC(ways[id]);\r\n                            reverseOpenLRLine.fow = RoutableTilesIntegration.getFOW(ways[id]);\r\n                            openLRLines[reverseOpenLRLine.getID()] = reverseOpenLRLine;\r\n                        }\r\n                        //since we only want to keep the nodes that are part of the road network, and not the other nodes of OSM, so we will add only those in the openLRNodes map\r\n                        openLRNodes[refToNodeId[ways[id].nodes[i]]] = osmNodes[refToNodeId[ways[id].nodes[i]]];\r\n                        openLRNodes[refToNodeId[ways[id].nodes[i+1]]] = osmNodes[refToNodeId[ways[id].nodes[i+1]]];\r\n                    // }\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            nodes: openLRNodes,\r\n            lines: openLRLines\r\n        }\r\n    }\r\n\r\n    static getFRC(osmWay){\r\n        if(osmWay.highway !== undefined && OsmFrcHighwayMapping[osmWay.highway.slice(4)] !== undefined){\r\n            return OsmFrcHighwayMapping[osmWay.highway.slice(37).toLowerCase()];\r\n        }\r\n        else{\r\n            return frcEnum.FRC_7;\r\n        }\r\n    }\r\n\r\n    static getFOW(osmWay){\r\n        if(osmWay.highway !== undefined\r\n            && osmWay.highway === \"https://w3id.org/openstreetmap/terms#Pedestrian\"\r\n            && osmWay.area !== undefined\r\n            && osmWay.area === \"yes\"\r\n        ){\r\n            return fowEnum.TRAFFICSQUARE;\r\n        }\r\n        else if(osmWay.junction !== undefined && osmWay.junction === \"roundabout\"){\r\n            return fowEnum.ROUNDABOUT;\r\n        }\r\n        else if(osmWay.highway !== undefined && OsmFowHighwayMapping[osmWay.highway.slice(37).toLowerCase()] !== undefined){\r\n            return OsmFowHighwayMapping[osmWay.highway.slice(37).toLowerCase()];\r\n        }\r\n        else {\r\n            return fowEnum.UNDEFINED;\r\n        }\r\n    }\r\n}\r\n","export let DATASET_URL = 'https://tiles.openplanner.team/planet/';","import axios from 'axios';\r\nimport ldfetch from \"ldfetch\";\r\nimport {DATASET_URL} from \"./const\";\r\n\r\n\r\nexport function loadNodesLineStringsWegenregisterAntwerpen(){\r\n    return new Promise((resolve, reject) => {\r\n        axios.get(\"https://portaal-stadantwerpen.opendata.arcgis.com/datasets/6bad868c084a43ef8031cfe1b96956b2_297.geojson \")\r\n            .then((data) => { resolve(data.data.features) })\r\n            .catch((error) => { reject(error) })\r\n    });\r\n}\r\n\r\nexport function fetchRoutableTile(z, x, y) {\r\n    return new Promise((resolve) => {\r\n        let fetch = new ldfetch({headers: {accept: 'application/ld+json'}});\r\n        fetch.get(DATASET_URL + z + \"/\" + x + \"/\" + y).then(\r\n            response => {\r\n                resolve(response)\r\n            }\r\n        )\r\n    });\r\n}\r\n\r\nexport function fetchOsmData(latLower,latUpper,longLower,longUpper) {\r\n    return new Promise((resolve, reject) => {\r\n        axios.get(\"https://api.openstreetmap.org/api/0.6/map?bbox=\"+longLower+\",\"+latLower+\",\"+longUpper+\",\"+latUpper)\r\n            .then((data) => resolve(data.data))\r\n            .catch((error) => {\r\n                reject(error)\r\n            })\r\n    })\r\n}","import {frcEnum} from \"../../OpenLR/map/Enum\";\r\n\r\n//based on https://www.agiv.be/~/media/agiv/producten/mrb/documenten/wegenregister_objectcataloog.pdf\r\n//or https://download.vlaanderen.be/Producten/GetDocument?id=280&title=Data_Wegenregister_v2_0_pdf&x=Data_Wegenregister_v2_0_pdf\r\nexport let WegenregisterAntwerpenFrcWegcatMapping = {\r\n    \"hoofdweg\": frcEnum.FRC_0,\r\n    \"primaire weg I\": frcEnum.FRC_1,\r\n    \"primaire weg II\": frcEnum.FRC_2,\r\n    \"primaire weg II type 1\": frcEnum.FRC_2,\r\n    \"primaire weg II type 2\": frcEnum.FRC_3,\r\n    \"primaire weg II type 3\": frcEnum.FRC_3,\r\n    \"primaire weg II type 4\": frcEnum.FRC_0,\r\n    \"secundaire weg\": frcEnum.FRC_4,\r\n    \"secundaire weg type 1\": frcEnum.FRC_4,\r\n    \"secundaire weg type 2\": frcEnum.FRC_5,\r\n    \"secundaire weg type 3\": frcEnum.FRC_5,\r\n    \"secundaire weg type 4\": frcEnum.FRC_5,\r\n    \"lokale weg\": frcEnum.FRC_6,\r\n    \"lokale weg type 1\": frcEnum.FRC_6,\r\n    \"lokale weg type 2\": frcEnum.FRC_6,\r\n    \"lokale weg type 3\": frcEnum.FRC_6,\r\n    \"niet gekend\": frcEnum.FRC_7,\r\n    \"niet van toepassing\": frcEnum.FRC_7\r\n};","import {fowEnum} from \"../../OpenLR/map/Enum\";\r\n\r\n//based on https://www.agiv.be/~/media/agiv/producten/mrb/documenten/wegenregister_objectcataloog.pdf\r\n//or https://download.vlaanderen.be/Producten/GetDocument?id=280&title=Data_Wegenregister_v2_0_pdf&x=Data_Wegenregister_v2_0_pdf\r\nexport let WegenregisterAntwerpenFowMorfMapping = {\r\n    \"autosnelweg\": fowEnum.MOTORWAY,\r\n    \"weg met gescheiden rijbanen die geen autosnelweg is\": fowEnum.MOTORWAY,\r\n    \"weg bestaande uit één rijbaan\": fowEnum.SINGLE_CARRIAGEWAY,\r\n    \"rotonde\": fowEnum.ROUNDABOUT,\r\n    \"speciale verkeerssituatie\": fowEnum.OTHER,\r\n    \"verkeersplein\": fowEnum.TRAFFICSQUARE,\r\n    \"op- of afrit, behorende tot een nietgelijkgrondse verbinding\": fowEnum.SLIPROAD,\r\n    \"op- of afrit, behorende tot een gelijkgrondse verbinding\": fowEnum.SLIPROAD,\r\n    \"parallelweg\": fowEnum.SLIPROAD,\r\n    \"ventweg\": fowEnum.SINGLE_CARRIAGEWAY,\r\n    \"in- of uitrit van een parking\": fowEnum.SLIPROAD,\r\n    \"in- of uitrit van een dienst\": fowEnum.SLIPROAD,\r\n    \"voetgangerszone\": fowEnum.OTHER,\r\n    \"wandel- of fietsweg, niet toegankelijk voor andere voertuigen\": fowEnum.OTHER,\r\n    \"tramweg, niet toegankelijk voor andere voertuigen\": fowEnum.OTHER,\r\n    \"dienstweg\": fowEnum.OTHER,\r\n    \"aardeweg\": fowEnum.OTHER,\r\n    \"veer\": fowEnum.OTHER,\r\n    \"niet gekend\": fowEnum.UNDEFINED\r\n};\r\n","// import MapDataBase from \"../OpenLR/map/MapDataBase\";\r\nimport Line from \"../OpenLR/map/Line\";\r\nimport Node from \"../OpenLR/map/Node\";\r\nimport {WegenregisterAntwerpenFrcWegcatMapping} from \"./FRCmappings/WegenregisterAntwerpenFrcWegcatMapping\";\r\nimport {frcEnum} from \"../OpenLR/map/Enum\";\r\nimport {WegenregisterAntwerpenFowMorfMapping} from \"./FOWmappings/WegenregisterAntwerpenFowMorfMapping\";\r\n\r\n/*\r\nThis class contains a demo implementation for use of openlr in the wegenregister Antwerpen (geojson).\r\n */\r\nexport default class WegenregisterAntwerpenIntegration{\r\n    static initMapDataBase(mapDataBase,features){\r\n        let nodesLines = WegenregisterAntwerpenIntegration.getNodesLines(features);\r\n        mapDataBase.setData(nodesLines.lines,nodesLines.nodes); //todo: set bounding box\r\n    }\r\n\r\n    static getNodesLines(features){\r\n        let openLRLines = {};\r\n        let openLRNodes = {};\r\n\r\n        for(let i=0;i<features.length;i++){\r\n            let directionIsUndef = features[i].properties.RIJRICHTING_AUTO === undefined || features[i].properties.RIJRICHTING_AUTO === null;\r\n            // if(!directionIsUndef){ // skip this if al roads should be added and not only the roads for cars\r\n                if(features[i].geometry.type === \"LineString\"){\r\n\r\n                    if(features[i].geometry.coordinates.length >= 2){\r\n                        let lat = features[i].geometry.coordinates[0][1];\r\n                        let long = features[i].geometry.coordinates[0][0];\r\n                        if(openLRNodes[lat+\"_\"+long] === undefined){\r\n                            openLRNodes[lat+\"_\"+long] = new Node(lat+\"_\"+long,lat,long);\r\n                        }\r\n\r\n                        for(let j=1;j<features[i].geometry.coordinates.length;j++){\r\n                            lat = features[i].geometry.coordinates[j][1];\r\n                            long = features[i].geometry.coordinates[j][0];\r\n                            if(openLRNodes[lat+\"_\"+long] === undefined){\r\n                                openLRNodes[lat+\"_\"+long] = new Node(lat+\"_\"+long,lat,long);\r\n                            }\r\n                            let prevLat = features[i].geometry.coordinates[j-1][1];\r\n                            let prevLong = features[i].geometry.coordinates[j-1][0];\r\n\r\n\r\n                            if(directionIsUndef || features[i].properties.RIJRICHTING_AUTO === \"enkel (mee)\" || features[i].properties.RIJRICHTING_AUTO === \"dubbel\"){\r\n                                openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long]\r\n                                    = new Line(prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long,openLRNodes[prevLat+\"_\"+prevLong],openLRNodes[lat+\"_\"+long]);\r\n                                openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long].frc = WegenregisterAntwerpenIntegration.getFRC(features[i].properties);\r\n                                openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long].fow = WegenregisterAntwerpenIntegration.getFOW(features[i].properties);\r\n                            }\r\n                            if(directionIsUndef || features[i].properties.RIJRICHTING_AUTO === \"enkel (tegen)\"  || features[i].properties.RIJRICHTING_AUTO === \"dubbel\"){\r\n                                openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong]\r\n                                    = new Line(lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong,openLRNodes[lat+\"_\"+long],openLRNodes[prevLat+\"_\"+prevLong]);\r\n                                openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong].frc = WegenregisterAntwerpenIntegration.getFRC(features[i].properties);\r\n                                openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong].fow = WegenregisterAntwerpenIntegration.getFOW(features[i].properties);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            // }\r\n        }\r\n        return {\r\n            nodes: openLRNodes,\r\n            lines: openLRLines\r\n        }\r\n    }\r\n\r\n    /***\r\n     * //Depricated Code, only for testing purposes\r\n    static initMapDataBaseDeprecatedNoRoadDirections(mapDataBase,features){\r\n        let nodesLines = WegenregisterAntwerpenIntegration.getNodesLinesDeprecatedNoRoadDirections(features);\r\n        mapDataBase.setData(nodesLines.lines,nodesLines.nodes);\r\n    }\r\n\r\n    static getNodesLinesDeprecatedNoRoadDirections(features){\r\n        let openLRLines = {};\r\n        let openLRNodes = {};\r\n        for(let i=0;i<features.length;i++){\r\n\r\n            if(features[i].geometry.type === \"LineString\"){\r\n                if(features[i].geometry.coordinates.length >= 2){\r\n                    let lat = features[i].geometry.coordinates[0][1];\r\n                    let long = features[i].geometry.coordinates[0][0];\r\n                    if(openLRNodes[lat+\"_\"+long] === undefined){\r\n                        openLRNodes[lat+\"_\"+long] = new Node(lat+\"_\"+long,lat,long);\r\n                    }\r\n                    for(let j=1;j<features[i].geometry.coordinates.length;j++){\r\n                        lat = features[i].geometry.coordinates[j][1];\r\n                        long = features[i].geometry.coordinates[j][0];\r\n                        if(openLRNodes[lat+\"_\"+long] === undefined){\r\n                            openLRNodes[lat+\"_\"+long] = new Node(lat+\"_\"+long,lat,long);\r\n                        }\r\n                        let prevLat = features[i].geometry.coordinates[j-1][1];\r\n                        let prevLong = features[i].geometry.coordinates[j-1][0];\r\n\r\n                        openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long]\r\n                            = new Line(prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long,openLRNodes[prevLat+\"_\"+prevLong],openLRNodes[lat+\"_\"+long]);\r\n                        openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long].frc = WegenregisterAntwerpenIntegration.getFRC(features[i].properties);\r\n                        openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long].fow = WegenregisterAntwerpenIntegration.getFOW(features[i].properties);\r\n\r\n                        openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong]\r\n                            = new Line(lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong,openLRNodes[lat+\"_\"+long],openLRNodes[prevLat+\"_\"+prevLong]);\r\n                        openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong].frc = WegenregisterAntwerpenIntegration.getFRC(features[i].properties);\r\n                        openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong].fow = WegenregisterAntwerpenIntegration.getFOW(features[i].properties);\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            nodes: openLRNodes,\r\n            lines: openLRLines\r\n        }\r\n    }\r\n\r\n    static initMapDataBaseDeprecatedAllLineStrings(mapDataBase,features){\r\n        let nodesLines = WegenregisterAntwerpenIntegration.getNodesLinesDeprecatedAllLineStrings(features);\r\n        mapDataBase.setData(nodesLines.lines,nodesLines.nodes);\r\n    }\r\n\r\n    static getNodesLinesDeprecatedAllLineStrings(features){\r\n        let openLRLines = {};\r\n        let openLRNodes = {};\r\n        for(let i=0;i<features.length;i++){\r\n\r\n            if(features[i].geometry.type === \"LineString\"){\r\n                if(features[i].geometry.coordinates.length >= 2){\r\n                    let lat = features[i].geometry.coordinates[0][1];\r\n                    let long = features[i].geometry.coordinates[0][0];\r\n                    if(openLRNodes[lat+\"_\"+long] === undefined){\r\n                        openLRNodes[lat+\"_\"+long] = new Node(lat+\"_\"+long,lat,long);\r\n                    }\r\n                    for(let j=1;j<features[i].geometry.coordinates.length;j++){\r\n                        lat = features[i].geometry.coordinates[j][1];\r\n                        long = features[i].geometry.coordinates[j][0];\r\n                        if(openLRNodes[lat+\"_\"+long] === undefined){\r\n                            openLRNodes[lat+\"_\"+long] = new Node(lat+\"_\"+long,lat,long);\r\n                        }\r\n                        let prevLat = features[i].geometry.coordinates[j-1][1];\r\n                        let prevLong = features[i].geometry.coordinates[j-1][0];\r\n\r\n                        if(features[i].properties.RIJRICHTING_AUTO === undefined || features[i].properties.RIJRICHTING_AUTO === null || features[i].properties.RIJRICHTING_AUTO === \"enkel (mee)\" || features[i].properties.RIJRICHTING_AUTO === \"dubbel\"){\r\n                            openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long]\r\n                                = new Line(prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long,openLRNodes[prevLat+\"_\"+prevLong],openLRNodes[lat+\"_\"+long]);\r\n                            openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long].frc = WegenregisterAntwerpenIntegration.getFRC(features[i].properties);\r\n                            openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long].fow = WegenregisterAntwerpenIntegration.getFOW(features[i].properties);\r\n                        }\r\n                        if(features[i].properties.RIJRICHTING_AUTO === undefined || features[i].properties.RIJRICHTING_AUTO === null || features[i].properties.RIJRICHTING_AUTO === \"enkel (tegen)\"  || features[i].properties.RIJRICHTING_AUTO === \"dubbel\"){\r\n                            openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong]\r\n                                = new Line(lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong,openLRNodes[lat+\"_\"+long],openLRNodes[prevLat+\"_\"+prevLong]);\r\n                            openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong].frc = WegenregisterAntwerpenIntegration.getFRC(features[i].properties);\r\n                            openLRLines[lat+\"_\"+long+\"_\"+prevLat+\"_\"+prevLong].fow = WegenregisterAntwerpenIntegration.getFOW(features[i].properties);\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            nodes: openLRNodes,\r\n            lines: openLRLines\r\n        }\r\n    }\r\n    */\r\n\r\n    static getFRC(properties){\r\n        if(properties !== undefined && properties[\"WEGCAT\"] !== undefined){\r\n            return WegenregisterAntwerpenFrcWegcatMapping[properties[\"WEGCAT\"]];\r\n        }\r\n        else{\r\n            return frcEnum.FRC_7;\r\n        }\r\n    }\r\n\r\n    static getFOW(properties){\r\n        if(properties !== undefined && properties[\"MORF\"] !== undefined){\r\n            return WegenregisterAntwerpenFowMorfMapping[properties[\"MORF\"]];\r\n        }\r\n        else{\r\n            return frcEnum.FRC_7;\r\n        }\r\n    }\r\n}\r\n","import Line from \"../OpenLR/map/Line\";\r\nimport Node from \"../OpenLR/map/Node\";\r\n\r\nexport default class GeoJsonIntegration{\r\n    static initMapDataBase(mapDataBase,features){\r\n        let nodesLines = GeoJsonIntegration.getNodesLines(features);\r\n        mapDataBase.setData(nodesLines.lines,nodesLines.nodes); //todo: set bounding box\r\n    }\r\n\r\n    static getNodesLines(features){\r\n        let openLRLines = {};\r\n        let openLRNodes = {};\r\n\r\n        for(let i=0;i<features.length;i++){\r\n            if(features[i].geometry.type === \"LineString\"){\r\n\r\n                if(features[i].geometry.coordinates.length >= 2){\r\n                    let lat = features[i].geometry.coordinates[0][1];\r\n                    let long = features[i].geometry.coordinates[0][0];\r\n                    if(openLRNodes[lat+\"_\"+long] === undefined){\r\n                        openLRNodes[lat+\"_\"+long] = new Node(lat+\"_\"+long,lat,long);\r\n                    }\r\n\r\n                    for(let j=1;j<features[i].geometry.coordinates.length;j++){\r\n                        lat = features[i].geometry.coordinates[j][1];\r\n                        long = features[i].geometry.coordinates[j][0];\r\n                        if(openLRNodes[lat+\"_\"+long] === undefined){\r\n                            openLRNodes[lat+\"_\"+long] = new Node(lat+\"_\"+long,lat,long);\r\n                        }\r\n                        let prevLat = features[i].geometry.coordinates[j-1][1];\r\n                        let prevLong = features[i].geometry.coordinates[j-1][0];\r\n\r\n\r\n                        openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long]\r\n                            = new Line(prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long,openLRNodes[prevLat+\"_\"+prevLong],openLRNodes[lat+\"_\"+long]);\r\n                        openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long].frc = GeoJsonIntegration.getFRC(features[i].properties);\r\n                        openLRLines[prevLat+\"_\"+prevLong+\"_\"+lat+\"_\"+long].fow = GeoJsonIntegration.getFOW(features[i].properties);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            nodes: openLRNodes,\r\n            lines: openLRLines\r\n        }\r\n    }\r\n\r\n    static getFRC(properties){\r\n        return undefined\r\n    }\r\n\r\n    static getFOW(properties){\r\n        return undefined;\r\n    }\r\n}","export let map = {\r\n    \"type\": \"FeatureCollection\",\r\n    \"features\": [\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397100806236267,\r\n                        51.212080675440326\r\n                    ],\r\n                    [\r\n                        4.3963927030563354,\r\n                        51.212183170064435\r\n                    ],\r\n                    [\r\n                        4.3940967321395865,\r\n                        51.212482251433954\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.394075274467467,\r\n                        51.212415042306645\r\n                    ],\r\n                    [\r\n                        4.397052526473999,\r\n                        51.212028587920976\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397208094596863,\r\n                        51.21207563471524\r\n                    ],\r\n                    [\r\n                        4.3975406885147095,\r\n                        51.21277124956351\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397073984146118,\r\n                        51.21200842499444\r\n                    ],\r\n                    [\r\n                        4.395963549613953,\r\n                        51.21114141080123\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397116899490356,\r\n                        51.21202690767745\r\n                    ],\r\n                    [\r\n                        4.397073984146118,\r\n                        51.21200842499444\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.39603865146637,\r\n                        51.21111116582538\r\n                    ],\r\n                    [\r\n                        4.397116899490356,\r\n                        51.21198826205907\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397116899490356,\r\n                        51.21198826205907\r\n                    ],\r\n                    [\r\n                        4.397173225879669,\r\n                        51.21202018670265\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397428035736084,\r\n                        51.21063732527733\r\n                    ],\r\n                    [\r\n                        4.397192001342773,\r\n                        51.211998343527874\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397192001342773,\r\n                        51.211998343527874\r\n                    ],\r\n                    [\r\n                        4.397173225879669,\r\n                        51.21202018670265\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397154450416565,\r\n                        51.21199498303851\r\n                    ],\r\n                    [\r\n                        4.397363662719726,\r\n                        51.21064404645396\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397116899490356,\r\n                        51.21202690767745\r\n                    ],\r\n                    [\r\n                        4.397154450416565,\r\n                        51.21199498303851\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397251009941101,\r\n                        51.21200842499444\r\n                    ],\r\n                    [\r\n                        4.3991392850875854,\r\n                        51.21176646918734\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397173225879669,\r\n                        51.21202018670265\r\n                    ],\r\n                    [\r\n                        4.397251009941101,\r\n                        51.21200842499444\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.399176836013794,\r\n                        51.21181351624941\r\n                    ],\r\n                    [\r\n                        4.397631883621215,\r\n                        51.21202186694646\r\n                    ],\r\n                    [\r\n                        4.397240281105041,\r\n                        51.21206555326336\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397631883621215,\r\n                        51.21202186694646\r\n                    ],\r\n                    [\r\n                        4.397419989109039,\r\n                        51.21201850645882\r\n                    ],\r\n                    [\r\n                        4.397242963314056,\r\n                        51.21204202986709\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397240281105041,\r\n                        51.21206555326336\r\n                    ],\r\n                    [\r\n                        4.397208094596863,\r\n                        51.21207563471524\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397194683551788,\r\n                        51.212055471809286\r\n                    ],\r\n                    [\r\n                        4.397135674953461,\r\n                        51.21206387302118\r\n                    ],\r\n                    [\r\n                        4.397116899490356,\r\n                        51.21202690767745\r\n                    ],\r\n                    [\r\n                        4.397173225879669,\r\n                        51.21202018670265\r\n                    ],\r\n                    [\r\n                        4.397194683551788,\r\n                        51.212055471809286\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397242963314056,\r\n                        51.21204202986709\r\n                    ],\r\n                    [\r\n                        4.397194683551788,\r\n                        51.212055471809286\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397194683551788,\r\n                        51.212055471809286\r\n                    ],\r\n                    [\r\n                        4.397208094596863,\r\n                        51.21207563471524\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397135674953461,\r\n                        51.21206387302118\r\n                    ],\r\n                    [\r\n                        4.397100806236267,\r\n                        51.212080675440326\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397052526473999,\r\n                        51.212028587920976\r\n                    ],\r\n                    [\r\n                        4.397116899490356,\r\n                        51.21202690767745\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.39750850200653,\r\n                        51.21278301107689\r\n                    ],\r\n                    [\r\n                        4.397159814834595,\r\n                        51.212085716164886\r\n                    ]\r\n                ]\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"Feature\",\r\n            \"properties\": {},\r\n            \"geometry\": {\r\n                \"type\": \"LineString\",\r\n                \"coordinates\": [\r\n                    [\r\n                        4.397159814834595,\r\n                        51.212085716164886\r\n                    ],\r\n                    [\r\n                        4.397135674953461,\r\n                        51.21206387302118\r\n                    ]\r\n                ]\r\n            }\r\n        }\r\n    ]\r\n};","import LRPNodeHelper from \"../coder/LRPNodeHelper\";\r\nimport {locationTypeEnum} from \"../map/Enum\";\r\n\r\n/**\r\n * function that takes lines and directly makes LRPs of them, without running through all the encoding steps\r\n * Can be used to skip the encoding completely. These LRPs can be decoded, but lack the benefit of the encoding.\r\n * The encoding step reduces the amount of LRPs to the bare minimum, which doesn't happen when using this method.\r\n * So if this method is used on 20 lines of which only the very first and last end points are valid, this method will return\r\n * 20 LRPs, wile the encoding would only return 2 LRPs. So use this method only on a small amount of lines.\r\n * @param lines\r\n * @returns {{LRPs: *, posOffset: number, negOffset: number, type: number}}\r\n * @constructor\r\n */\r\nexport function LinesDirectlyToLRPs(lines){\r\n    if(lines.length === 0){\r\n        throw Error(\"The array of lines is empty\");\r\n    }\r\n    let shortestPaths = [];\r\n    let encLines = lines.length >= 2 ? lines : [lines[0],lines[0]];\r\n    for(let i=0;i<encLines.length-1;i++){\r\n        shortestPaths.push({lines: [], length: 0});\r\n    }\r\n    return {LRPs: LRPNodeHelper.lrpLinesToLRPs(encLines,shortestPaths), posOffset:0, negOffset: 0, type: locationTypeEnum.LINE_LOCATION};\r\n}","export function getTileXYForLocation(latitude, longitude, zoom){\r\n    let x = _long2tile(longitude,zoom);\r\n    let y = _lat2tile(latitude,zoom);\r\n    return {x: x, y: y};\r\n}\r\n\r\nexport function tile2boundingBox(x,y,zoom){\r\n    let north = _tile2lat(y,zoom);\r\n    let south = _tile2lat(y+1,zoom);\r\n    let west = _tile2long(x, zoom);\r\n    let east = _tile2long(x+1,zoom);\r\n    return {\r\n        latUpper: north,\r\n        longLower: west,\r\n        latLower: south,\r\n        longUpper: east\r\n    }\r\n}\r\n\r\n/*\r\nhttps://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#ECMAScript_.28JavaScript.2FActionScript.2C_etc..29\r\n */\r\nfunction _long2tile(lon,zoom) { return (Math.floor((lon+180)/360*Math.pow(2,zoom))); }\r\nfunction _lat2tile(lat,zoom)  { return (Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom))); }\r\n\r\nfunction _tile2long(x,z) {\r\n    return (x/Math.pow(2,z)*360-180);\r\n}\r\nfunction _tile2lat(y,z) {\r\n    let n=Math.PI-2*Math.PI*y/Math.pow(2,z);\r\n    return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));\r\n}","export let data = `@prefix dcterms: <http://purl.org/dc/terms/>.\r\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.\r\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.\r\n@prefix skos: <http://www.w3.org/2004/02/skos/core#>.\r\n@prefix skos-thes: <http://purl.org/iso25964/skos-thes#>.\r\n@prefix void: <http://rdfs.org/ns/void#>.\r\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.\r\n@prefix otl: <https://w3id.org/opentrafficlights#>.\r\n\r\n<https://lodi.ilabt.imec.be/opentrafficlights/rawdata#Dataset> rdfs:type void:Dataset;\r\n    dcterms:subject <http://dbpedia.org/resource/Signal_timing>, <http://dbpedia.org/resource/Traffic_light>.\r\n_:b0_connection1 a otl:Connection;\r\n    otl:departureLane _:b0_lane1;\r\n    otl:arrivalLane _:b0_lane11;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/6>.\r\n_:b0_connection2 a otl:Connection;\r\n    otl:departureLane _:b0_lane2;\r\n    otl:arrivalLane _:b0_lane9;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/7>.\r\n_:b0_connection3 a otl:Connection;\r\n    otl:departureLane _:b0_lane2;\r\n    otl:arrivalLane _:b0_lane7;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/7>.\r\n_:b0_connection4 a otl:Connection;\r\n    otl:departureLane _:b0_lane2;\r\n    otl:arrivalLane _:b0_lane5;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/7>.\r\n_:b0_connection5 a otl:Connection;\r\n    otl:departureLane _:b0_lane8;\r\n    otl:arrivalLane _:b0_lane3;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/5>.\r\n_:b0_connection6 a otl:Connection;\r\n    otl:departureLane _:b0_lane8;\r\n    otl:arrivalLane _:b0_lane5;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/5>.\r\n_:b0_connection7 a otl:Connection;\r\n    otl:departureLane _:b0_lane8;\r\n    otl:arrivalLane _:b0_lane7;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/5>.\r\n_:b0_connection8 a otl:Connection;\r\n    otl:departureLane _:b0_lane8;\r\n    otl:arrivalLane _:b0_lane11;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/5>.\r\n_:b0_connection9 a otl:Connection;\r\n    otl:departureLane _:b0_lane6;\r\n    otl:arrivalLane _:b0_lane5;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/4>.\r\n_:b0_connection10 a otl:Connection;\r\n    otl:departureLane _:b0_lane6;\r\n    otl:arrivalLane _:b0_lane3;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/4>.\r\n_:b0_connection11 a otl:Connection;\r\n    otl:departureLane _:b0_lane6;\r\n    otl:arrivalLane _:b0_lane11;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/4>.\r\n_:b0_connection12 a otl:Connection;\r\n    otl:departureLane _:b0_lane6;\r\n    otl:arrivalLane _:b0_lane9;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/4>.\r\n_:b0_connection13 a otl:Connection;\r\n    otl:departureLane _:b0_lane4;\r\n    otl:arrivalLane _:b0_lane3;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/3>.\r\n_:b0_connection14 a otl:Connection;\r\n    otl:departureLane _:b0_lane4;\r\n    otl:arrivalLane _:b0_lane11;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/3>.\r\n_:b0_connection15 a otl:Connection;\r\n    otl:departureLane _:b0_lane4;\r\n    otl:arrivalLane _:b0_lane9;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/3>.\r\n_:b0_connection16 a otl:Connection;\r\n    otl:departureLane _:b0_lane4;\r\n    otl:arrivalLane _:b0_lane7;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/3>.\r\n_:b0_connection17 a otl:Connection;\r\n    otl:departureLane _:b0_lane10;\r\n    otl:arrivalLane _:b0_lane3;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/1>.\r\n_:b0_connection18 a otl:Connection;\r\n    otl:departureLane _:b0_lane10;\r\n    otl:arrivalLane _:b0_lane5;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/1>.\r\n_:b0_connection19 a otl:Connection;\r\n    otl:departureLane _:b0_lane10;\r\n    otl:arrivalLane _:b0_lane7;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/1>.\r\n_:b0_connection20 a otl:Connection;\r\n    otl:departureLane _:b0_lane10;\r\n    otl:arrivalLane _:b0_lane9;\r\n    otl:signalGroup <https://opentrafficlights.org/id/signalgroup/K648/1>.\r\n_:b0_lane1 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2120579 4.3974731, 51.2118214 4.3991321)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Kronenburgstraat (> nr. 48)\".\r\n_:b0_lane2 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2120361 4.3974671, 51.2120058 4.3976971, 51.2120184 4.3977501)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Kronenburgstraat (> nr. 48)\".\r\n_:b0_lane3 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2118379 4.3970829, 51.2111054 4.3961904)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Volkstraat\".\r\n_:b0_lane4 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2117840 4.3972854, 51.2107036 4.3974678)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Geuzenstraat\".\r\n_:b0_lane5 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2117896 4.3972204, 51.2114204 4.3973075, 51.2106996 4.3974309)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Geuzenstraat\".\r\n_:b0_lane6 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2118379 4.3970829, 51.2111054 4.3961904)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Volkstraat\".\r\n_:b0_lane7 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2118758 4.3970172, 51.2111339 4.3961220)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Volkstraat\".\r\n_:b0_lane8 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2120563 4.3969880, 51.2121071 4.3965394, 51.2123772 4.3942387)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Kronenburgstraat (< nr. 48)\".\r\n_:b0_lane9 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2121009 4.3969997, 51.2124223 4.3942465)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Kronenburgstraat (< nr. 48)\".\r\n_:b0_lane10 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2122527 4.3973091, 51.2127026 4.3975384)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Nationalestraat\".\r\n_:b0_lane11 a otl:Lane;\r\n    <http://www.opengis.net/#geosparql/wktLiteral> \"LINESTRING (51.2122440 4.3973510, 51.2126980 4.3975804)\";\r\n    <http://dbpedia.org/ontology/width> \"100\";\r\n    dcterms:description \"Nationalestraat\".\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> rdfs:type otl:Signalgroup.\r\n<https://opentrafficlights.org/id/signalgroup/K648/2> rdfs:type otl:Signalgroup.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> rdfs:type otl:Signalgroup.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> rdfs:type otl:Signalgroup.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> rdfs:type otl:Signalgroup.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> rdfs:type otl:Signalgroup.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> rdfs:type otl:Signalgroup.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> rdfs:type otl:Signalgroup.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> rdfs:type otl:Signalgroup.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase> a skos:ConceptScheme;\r\n    dcterms:identifier \"SIGNAL PHASE\";\r\n    skos:hasTopConcept <https://w3id.org/opentrafficlights/thesauri/signalphase/0>, <https://w3id.org/opentrafficlights/thesauri/signalphase/1>, <https://w3id.org/opentrafficlights/thesauri/signalphase/2>, <https://w3id.org/opentrafficlights/thesauri/signalphase/3>, <https://w3id.org/opentrafficlights/thesauri/signalphase/4>, <https://w3id.org/opentrafficlights/thesauri/signalphase/5>, <https://w3id.org/opentrafficlights/thesauri/signalphase/6>, <https://w3id.org/opentrafficlights/thesauri/signalphase/7>, <https://w3id.org/opentrafficlights/thesauri/signalphase/8>, <https://w3id.org/opentrafficlights/thesauri/signalphase/9>;\r\n    skos:prefLabel \"Signal phase\"@en, \"Signaal fase\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/0> a skos:Concept;\r\n    dcterms:identifier \"0\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Unavailable\"@en, \"Niet beschikbaar\"@nl;\r\n    skos:note \"This phase is used for unknown or error.\"@en, \"Duidt aan dat er een probleem is gedetecteerd of de fase is onbekend.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/1> a skos:Concept;\r\n    dcterms:identifier \"1\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Unlit (DARK)\"@en, \"Onverlicht (DONKER)\"@en;\r\n    skos:note \"Stop vehicle at stop line. Do not proceed until it's safe.\"@en, \"Stop het voertuig aan de stoplijn. Wacht tot het veilig is.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/2> a skos:Concept;\r\n    dcterms:identifier \"2\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Stop Then Proceed (flashing)\"@en, \"Stop-dan-verdergaan (knipperlicht)\"@nl;\r\n    skos:note \"Stop vehicle at stop line. Do not proceed until it's safe.\"@en, \"Stop het voertuig aan de stoplijn. Wacht tot het veilig is.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/3> a skos:Concept;\r\n    dcterms:identifier \"3\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Stop And Remain\"@en, \"Stop-En-Wacht\"@nl;\r\n    skos:note \"Stop vehicle at stop line. Do not proceed.\"@en, \"Stop het voertuig aan de stoplijn. Wacht.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/4> a skos:Concept;\r\n    dcterms:identifier \"4\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Pre-Movement\"@en, \"Voor-vertrek\"@nl;\r\n    skos:note \"Stop vehicle. Prepare to proceed.\"@en, \"Stop het voertuig. Maak klaar om te vertrekken.\"@nl, \"Stop het voertuig. Maak klaar om te vertrekken.\"@nl;\r\n    skos:editorialNote \"Used in the European Union.\"@en, \"Van toepassing in Europese Unie.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/5> a skos:Concept;\r\n    dcterms:identifier \"5\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Permissive Movement Allowed\"@en, \"Verdergaan is toegelaten onder voorwaarden.\"@nl;\r\n    skos:note \"Proceed with caution. Must yield to all conflicting traffic.\"@en, \"Ga verder onder voorwaarde dat voorrang gegeven wordt bij conflict.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/6> a skos:Concept;\r\n    dcterms:identifier \"6\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Protected Movement Allowed\"@en, \"Ga verder met voorrang-garantie.\"@nl;\r\n    skos:note \"Proceed in direction indicated.\"@en, \"Ga verder in de aangeduide richting.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/7> a skos:Concept;\r\n    dcterms:identifier \"7\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Permissive Clearance\"@en, \"Kruispunt vrijmaken zonder voorrang.\"@nl;\r\n    skos:note \"Prepare to stop. Proceed if unable to stop. Conflicting traffic may be present.\"@en, \"Stop indien mogelijk. Anders maak kruispunt vrij. Conflicterend verkeer kan aanwezig zijn.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/8> a skos:Concept;\r\n    dcterms:identifier \"8\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Protected Clearance\"@en, \"Kruispunt vrijmaken met voorrang-garantie.\"@nl;\r\n    skos:note \"Prepare to stop. Proceed if unable to stop in direction indicated.\"@en, \"Stop indien mogelijk. Anders maak kruispunt vrij.\"@nl.\r\n<https://w3id.org/opentrafficlights/thesauri/signalphase/9> a skos:Concept;\r\n    dcterms:identifier \"9\"^^xsd:integer;\r\n    skos:inScheme <https://w3id.org/opentrafficlights/thesauri/signalphase>;\r\n    skos:prefLabel \"Caution Conflicting Traffic (Flashing)\"@en, \"Pas op voor conflicterend verkeer.\"@nl;\r\n    skos:note \"Proceed with caution. Conflicting traffic may be present at intersection conflict area.\"@en, \"Ga opgelet verder. Mogelijk is er conflicterend verkeer op het kruispunt.\"@nl.\r\n\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:45.018Z> {\r\n_:b3072910_b9851902 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:04.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:37:07.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851902.\r\n_:b3072910_b9851903 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:45.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851903.\r\n_:b3072910_b9851904 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:45.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851904.\r\n_:b3072910_b9851905 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851905.\r\n_:b3072910_b9851906 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:30.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:45.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851906.\r\n_:b3072910_b9851907 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851907.\r\n_:b3072910_b9851908 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:45.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851908.\r\n_:b3072910_b9851909 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/12> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851909.\r\n_:b3072910_b9851910 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:45.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851910.\r\n_:b3072910_b9851911 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:45.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/10> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851911.\r\n_:b3072910_b9851912 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/11> <https://w3id.org/opentrafficlights#signalState> _:b3072910_b9851912\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:45.018Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:45.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:44.618Z> {\r\n_:b3072907_b9851901 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:30.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:44.618Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072907_b9851901\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:44.618Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:44.618Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:44.018Z> {\r\n_:b3072903_b9851890 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:04.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:37:07.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851890.\r\n_:b3072903_b9851891 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:44.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851891.\r\n_:b3072903_b9851892 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:44.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851892.\r\n_:b3072903_b9851893 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851893.\r\n_:b3072903_b9851894 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:44.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:44.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851894.\r\n_:b3072903_b9851895 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851895.\r\n_:b3072903_b9851896 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:44.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851896.\r\n_:b3072903_b9851897 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/12> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851897.\r\n_:b3072903_b9851898 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:44.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851898.\r\n_:b3072903_b9851899 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:44.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/10> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851899.\r\n_:b3072903_b9851900 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/11> <https://w3id.org/opentrafficlights#signalState> _:b3072903_b9851900\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:44.018Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:44.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:43.018Z> {\r\n_:b3072898_b9851879 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:04.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:37:07.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851879.\r\n_:b3072898_b9851880 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:43.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851880.\r\n_:b3072898_b9851881 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:43.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851881.\r\n_:b3072898_b9851882 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851882.\r\n_:b3072898_b9851883 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:44.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:44.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851883.\r\n_:b3072898_b9851884 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851884.\r\n_:b3072898_b9851885 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:43.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851885.\r\n_:b3072898_b9851886 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/12> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851886.\r\n_:b3072898_b9851887 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:43.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851887.\r\n_:b3072898_b9851888 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:43.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/10> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851888.\r\n_:b3072898_b9851889 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/11> <https://w3id.org/opentrafficlights#signalState> _:b3072898_b9851889\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:43.018Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:43.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:42.018Z> {\r\n_:b3072895_b9851868 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:04.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:37:07.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851868.\r\n_:b3072895_b9851869 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:42.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851869.\r\n_:b3072895_b9851870 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:42.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851870.\r\n_:b3072895_b9851871 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851871.\r\n_:b3072895_b9851872 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:44.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:44.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851872.\r\n_:b3072895_b9851873 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851873.\r\n_:b3072895_b9851874 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:42.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851874.\r\n_:b3072895_b9851875 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/12> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851875.\r\n_:b3072895_b9851876 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:42.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851876.\r\n_:b3072895_b9851877 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:42.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/10> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851877.\r\n_:b3072895_b9851878 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/11> <https://w3id.org/opentrafficlights#signalState> _:b3072895_b9851878\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:42.018Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:42.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:41.617Z> {\r\n_:b3072892_b9851867 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:44.417Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:44.417Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072892_b9851867\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:41.617Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:41.617Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:41.019Z> {\r\n_:b3072888_b9851856 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:04.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:37:07.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851856.\r\n_:b3072888_b9851857 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:41.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851857.\r\n_:b3072888_b9851858 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:41.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851858.\r\n_:b3072888_b9851859 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851859.\r\n_:b3072888_b9851860 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:41.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:41.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851860.\r\n_:b3072888_b9851861 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851861.\r\n_:b3072888_b9851862 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:41.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851862.\r\n_:b3072888_b9851863 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/12> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851863.\r\n_:b3072888_b9851864 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:13.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:41.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851864.\r\n_:b3072888_b9851865 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:41.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/10> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851865.\r\n_:b3072888_b9851866 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/11> <https://w3id.org/opentrafficlights#signalState> _:b3072888_b9851866\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:41.019Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:41.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:40.018Z> {\r\n_:b3072883_b9851845 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:04.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:37:07.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851845.\r\n_:b3072883_b9851846 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:40.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851846.\r\n_:b3072883_b9851847 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:40.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851847.\r\n_:b3072883_b9851848 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851848.\r\n_:b3072883_b9851849 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:41.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:41.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851849.\r\n_:b3072883_b9851850 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851850.\r\n_:b3072883_b9851851 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:40.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851851.\r\n_:b3072883_b9851852 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/12> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851852.\r\n_:b3072883_b9851853 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:40.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851853.\r\n_:b3072883_b9851854 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:40.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/10> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851854.\r\n_:b3072883_b9851855 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/11> <https://w3id.org/opentrafficlights#signalState> _:b3072883_b9851855\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:40.018Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:40.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:39.018Z> {\r\n_:b3072878_b9851834 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:04.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:37:07.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851834.\r\n_:b3072878_b9851835 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:39.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851835.\r\n_:b3072878_b9851836 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:39.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851836.\r\n_:b3072878_b9851837 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851837.\r\n_:b3072878_b9851838 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:41.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:41.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851838.\r\n_:b3072878_b9851839 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851839.\r\n_:b3072878_b9851840 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:39.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851840.\r\n_:b3072878_b9851841 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/12> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851841.\r\n_:b3072878_b9851842 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:39.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851842.\r\n_:b3072878_b9851843 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:39.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/10> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851843.\r\n_:b3072878_b9851844 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.418Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/11> <https://w3id.org/opentrafficlights#signalState> _:b3072878_b9851844\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:39.018Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:39.018Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:38.019Z> {\r\n_:b3072875_b9851823 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/0>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:04.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:37:07.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/6> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851823.\r\n_:b3072875_b9851824 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:38.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/7> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851824.\r\n_:b3072875_b9851825 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:38.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/5> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851825.\r\n_:b3072875_b9851826 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/4> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851826.\r\n_:b3072875_b9851827 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:41.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:41.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/3> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851827.\r\n_:b3072875_b9851828 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:48.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:35:48.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/1> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851828.\r\n_:b3072875_b9851829 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:38.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/8> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851829.\r\n_:b3072875_b9851830 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/12> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851830.\r\n_:b3072875_b9851831 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:13.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:38.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/9> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851831.\r\n_:b3072875_b9851832 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/3>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:36:12.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T09:35:38.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/10> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851832.\r\n_:b3072875_b9851833 <http://www.w3.org/2000/01/rdf-schema#type> <https://w3id.org/opentrafficlights#SignalState>;\r\n    <https://w3id.org/opentrafficlights#signalPhase> <https://w3id.org/opentrafficlights/thesauri/signalphase/6>;\r\n    <https://w3id.org/opentrafficlights#minEndTime> \"2019-02-14T08:35:55.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>;\r\n    <https://w3id.org/opentrafficlights#maxEndTime> \"2019-02-14T08:36:13.419Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n<https://opentrafficlights.org/id/signalgroup/K648/11> <https://w3id.org/opentrafficlights#signalState> _:b3072875_b9851833\r\n}\r\n<https://opentrafficlights.org/spat/K648?time=2019-02-14T08:35:38.019Z> <http://www.w3.org/ns/prov#generatedAtTime> \"2019-02-14T08:35:38.019Z\"^^<http://www.w3.org/2001/XMLSchema#date>.\r\n\r\n<#Metadata> {\r\n<https://lodi.ilabt.imec.be/observer/rawdata/latest> <http://www.w3.org/ns/hydra/core#search> <https://lodi.ilabt.imec.be/observer/rawdata/latest#search>.\r\n<https://lodi.ilabt.imec.be/observer/rawdata/latest#search> a <http://www.w3.org/ns/hydra/core#IriTemplate>;\r\n    <http://www.w3.org/ns/hydra/core#template> \"https://lodi.ilabt.imec.be/observer/rawdata{?time}\";\r\n    <http://www.w3.org/ns/hydra/core#variableRepresentation> <http://www.w3.org/ns/hydra/core#BasicRepresentation>;\r\n    <http://www.w3.org/ns/hydra/core#mapping> <https://lodi.ilabt.imec.be/observer/rawdata/latest#mapping>.\r\n<https://lodi.ilabt.imec.be/observer/rawdata/latest#mapping> a <http://www.w3.org/ns/hydra/core#IriTemplateMapping>;\r\n    <http://www.w3.org/ns/hydra/core#variable> \"time\";\r\n    <http://www.w3.org/ns/hydra/core#required> \"true\"^^<http://www.w3.org/2001/XMLSchema#boolean>.\r\n<https://lodi.ilabt.imec.be/observer/rawdata/latest> <http://rdfs.org/ns/void#inDataset> <https://lodi.ilabt.imec.be/observer/rawdata#Dataset>;\r\n    <http://creativecommons.org/ns#license> <https://creativecommons.org/publicdomain/zero/1.0/>;\r\n    <http://www.w3.org/ns/hydra/core#previous> <https://lodi.ilabt.imec.be/observer/rawdata/fragments?time=2019-02-14T08:35:26.618Z>\r\n}\r\n`;","import geojsonrbush from 'geojson-rbush'\r\nimport {polygon} from '@turf/helpers';\r\n\r\nexport default class GeoJSONRBushPolygonSearchTree{\r\n    constructor(featureCollection){\r\n        this.tree = geojsonrbush();\r\n        this.addPolygons(featureCollection);\r\n    }\r\n\r\n    addPolygons(featureCollection){\r\n        this.tree.load(featureCollection);\r\n    }\r\n\r\n    //dist given in meters\r\n    //uses an approximate square bounding box around the given point, so it is possible that lines are returned that\r\n    //are further than dist away. It is still necessary to iterate the returned polygons and calculate their real distance.\r\n    findCloseBy(lat,long,dist){\r\n        let earthRadius = 6371000;\r\n        let latDiff = this.toDegrees(dist/earthRadius);\r\n        let longDiff = this.toDegrees(dist/(Math.cos(this.toRadians(lat)) * earthRadius));\r\n        let latUpper = lat+latDiff;\r\n        let latLower = lat-latDiff;\r\n        let longUpper = long+longDiff;\r\n        let longLower = long-longDiff;\r\n        return this.findInRange(latLower,longLower,latUpper,longUpper);\r\n    }\r\n\r\n    findInRange(latLower,longLower,latUpper,longUpper){\r\n        let p = polygon([[[longLower,latLower],[longLower,latUpper],[longUpper,latUpper],[longUpper,latLower],[longLower,latLower]]]);\r\n        let r = this.tree.search(p);\r\n        return r.features;\r\n    }\r\n\r\n    toRadians(degrees){\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    toDegrees(radians){\r\n        return radians / Math.PI * 180\r\n    }\r\n\r\n    //todo: remove polygons\r\n}","// import RbushPolygonSearchTree from './searchTree/RbushPolygonSearchTree'\r\nimport GeoJSONRBushPolygonSearchTree from \"./searchTree/GeoJSONRBushPolygonSearchTree\";\r\n\r\nexport default class Catalog{\r\n    constructor(){\r\n        this.searchTree = undefined;\r\n        this.amountOfDatasets = 0;\r\n    }\r\n\r\n    addCatalogPage(sets){\r\n        // BEFORE\r\n        // 1: check if the data set in the catalog has a spatial tag (filled with a polygon)\r\n        // 2: check if the data set in the catalog has one of the tags from the tags list\r\n        // 3: if both 1 and 2 are satisfied, get the geo+json data, a unique id (URL to the opendata.vlaanderen page for this dataset) and the distribution url of the data set\r\n        // NOW\r\n        // 3: create a new geo json feature with the geo+json data as geometry and the identifier and distribution url as properties\r\n        // 4: push this feature to the feature collection which will be used in the lookup structure\r\n        let features = Catalog._createFeaturesForGeoSpatialDataSets(sets);\r\n        let featureCollection = {\r\n            type: 'FeatureCollection',\r\n            features: features\r\n        };\r\n        if(this.searchTree === undefined){\r\n            this.searchTree = new GeoJSONRBushPolygonSearchTree(featureCollection);\r\n        }\r\n        else{\r\n            this.searchTree.addPolygons(featureCollection);\r\n        }\r\n        this.amountOfDatasets += features.length;\r\n\r\n        return {\r\n            currentPage: sets.currentPage,\r\n            nextPage: sets.nextPage,\r\n            lastPage: sets.lastPage\r\n        }\r\n    }\r\n\r\n    static _createFeaturesForGeoSpatialDataSets(data){\r\n        let featureCollection = [];\r\n        for(let set in data.dataSets){\r\n            if(data.dataSets.hasOwnProperty(set) && data.dataSets[set].geojson !== undefined && data.dataSets[set].hasValidKeyword){\r\n                featureCollection.push({\r\n                    type: 'Feature',\r\n                    properties: {\r\n                        id: set,\r\n                        distribution: data.distributions[data.dataSets[set].distribution]\r\n                    },\r\n                    geometry: data.dataSets[set].geojson\r\n                });\r\n            }\r\n        }\r\n        return featureCollection;\r\n    }\r\n\r\n    getDataSetsByDistance(lat,long,dist){\r\n        return this.searchTree.findCloseBy(lat,long,dist);\r\n    }\r\n\r\n    getDataSetsInRange(latLower,latUpper,longLower,longUpper){\r\n        return this.searchTree.findInRange(latLower,longLower,latUpper,longUpper);\r\n    }\r\n\r\n    getDatasetCount(){\r\n        return this.amountOfDatasets;\r\n    }\r\n}","import n3 from 'n3';\r\n\r\nconst { DataFactory } = n3;\r\nconst { namedNode } = DataFactory;\r\n\r\nexport function parseAndStoreQuads(_doc){\r\n    return new Promise(resolve => {\r\n        const parser = new n3.Parser();\r\n        const store = new n3.Store();\r\n        parser.parse(_doc, (error, quad, prefixes) => {\r\n            if(quad)\r\n                store.addQuad(quad);\r\n            else\r\n                resolve(store);\r\n        })\r\n    });\r\n}\r\n\r\nexport async function getDataSets(_store){\r\n    let dataSets = {};\r\n    await _store\r\n        .getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode('http://www.w3.org/ns/dcat#Dataset'))\r\n        .forEach(\r\n            (quad) => {dataSets[quad.subject.value] = {}}\r\n        );\r\n    return dataSets;\r\n}\r\n\r\nexport async function getDistributions(_store){\r\n    let distributions = {};\r\n    let distributionsData = {};\r\n    await _store\r\n        .getQuads(null, namedNode(\"http://www.w3.org/ns/dcat#distribution\"), null)\r\n        .forEach(\r\n            (quad) => {distributions[quad.subject.value]=quad.object.value}\r\n        );\r\n    for(let key in distributions){\r\n        if(distributions.hasOwnProperty(key)){\r\n            await _store\r\n                .getQuads(namedNode(distributions[key]), null, null)\r\n                .forEach(\r\n                    (quad) => {\r\n                        if(distributionsData[distributions[key]] === undefined){\r\n                            distributionsData[distributions[key]] = {};\r\n                        }\r\n                        distributionsData[distributions[key]][quad.predicate.value]=quad.object.value\r\n                    }\r\n                );\r\n        }\r\n    }\r\n\r\n    return {\r\n        distributionsData: distributionsData,\r\n        distributions: distributions\r\n    };\r\n}\r\n\r\nexport async function getLocationIDtoDataSet(_store){\r\n    let locationIDtoDataSet = {};\r\n    await _store\r\n        .getQuads(null, namedNode(\"http://purl.org/dc/terms/spatial\"), null)\r\n        .forEach(\r\n            (quad) => {locationIDtoDataSet[quad.subject.value] = quad.object.value;}\r\n        );\r\n    return locationIDtoDataSet;\r\n}\r\n\r\nexport async function getGeometries(_store){\r\n    let geometries = {};\r\n    await _store\r\n        .getQuads(null, namedNode(\"http://www.w3.org/ns/locn#geometry\"), null)\r\n        .forEach(\r\n            (quad) => {\r\n                if(quad.object.value[0] === \"{\")\r\n                    geometries[quad.subject.value] = JSON.parse(quad.object.value);\r\n            }\r\n        );\r\n    return geometries;\r\n}\r\n\r\nexport async function getKeywords(_store){\r\n    let keyWords = [];\r\n    await _store\r\n        .getQuads(null, namedNode(\"http://www.w3.org/ns/dcat#keyword\"), null)\r\n        .forEach(\r\n            (quad) => {\r\n                if(keyWords[quad.subject.value] === undefined){\r\n                    keyWords[quad.subject.value] = [];\r\n                }\r\n                keyWords[quad.subject.value].push(quad.object.value);\r\n            }\r\n        );\r\n    return keyWords;\r\n}\r\n\r\nexport async function getPagingInfo(_store){\r\n    let paging = {\r\n        currentPage: undefined,\r\n        nextPage: undefined,\r\n        lastPage: undefined\r\n    };\r\n    await _store\r\n        .getQuads(null, null, namedNode(\"http://www.w3.org/ns/hydra/core#PagedCollection\"))\r\n        .forEach(\r\n            (quad) => {\r\n                paging.currentPage = quad.subject.value;\r\n            }\r\n        );\r\n    if(paging.currentPage !== undefined){\r\n        await _store\r\n            .getQuads(this.currentPage, namedNode(\"http://www.w3.org/ns/hydra/core#lastPage\"), null)\r\n            .forEach(\r\n                (quad) => {\r\n                    paging.lastPage = quad.object.value;\r\n                }\r\n            );\r\n        await _store\r\n            .getQuads(this.currentPage, namedNode(\"http://www.w3.org/ns/hydra/core#nextPage\"), null)\r\n            .forEach(\r\n                (quad) => {\r\n                    paging.nextPage = quad.object.value;\r\n                }\r\n            );\r\n    }\r\n    return paging;\r\n}\r\n\r\n","\r\n\r\nimport {\r\n    getDataSets, getDistributions, getGeometries, getKeywords, getLocationIDtoDataSet,\r\n    getPagingInfo\r\n} from \"./Parser\";\r\n\r\nexport function getDataSetsFromTriples(triples, keywords=[]){\r\n    let dataSets = {};\r\n    let distributions = {};\r\n    let locationIDtoDataSet = {};\r\n    let currentPage = undefined;\r\n    let lastPage = undefined;\r\n    let nextPage = undefined;\r\n    triples.forEach((triple)=>{\r\n        if(triple.predicate.value === \"http://www.w3.org/ns/dcat#distribution\"){\r\n            if(dataSets[triple.subject.value] === undefined){\r\n                dataSets[triple.subject.value] = {};\r\n            }\r\n            dataSets[triple.subject.value].distribution = triple.object.value;\r\n            if(distributions[triple.object.value] === undefined){\r\n                distributions[triple.object.value] = {};\r\n            }\r\n        }\r\n\r\n        if(triple.predicate.value === \"http://purl.org/dc/terms/spatial\"){\r\n            if(dataSets[triple.subject.value] === undefined){\r\n                dataSets[triple.subject.value] = {};\r\n            }\r\n            locationIDtoDataSet[triple.object.value] = triple.subject.value;\r\n        }\r\n\r\n        if(\r\n            triple.predicate.value === \"http://www.w3.org/ns/locn#geometry\"\r\n            && triple.object.value[0] === \"{\"\r\n        ){\r\n            if(locationIDtoDataSet[triple.subject.value] === undefined){ //makes assumption about order of triples\r\n                throw Error(triple.subject.value + \" not previously encountered!\");\r\n            }\r\n            // if order of triples is random, use geometries[triple.subject.value] = ...\r\n            // and iterate its properties in the end to create dataSets[locationIDtoDataSet[key]] .geojson = geometries[key]\r\n            dataSets[locationIDtoDataSet[triple.subject.value]].geojson = JSON.parse(triple.object.value);\r\n        }\r\n\r\n        if(triple.predicate.value === \"http://www.w3.org/ns/dcat#keyword\"){\r\n            if(dataSets[triple.subject.value] === undefined){\r\n                dataSets[triple.subject.value] = {};\r\n            }\r\n            if(dataSets[triple.subject.value].keywords === undefined){\r\n                dataSets[triple.subject.value].keywords = [];\r\n            }\r\n            if(keywords.length === 0 || keywords.includes(triple.object.value)){\r\n                dataSets[triple.subject.value].hasValidKeyword = true;\r\n            }\r\n            dataSets[triple.subject.value].keywords.push(triple.object.value);\r\n        }\r\n\r\n        if(distributions[triple.subject.value] !== undefined){\r\n            distributions[triple.subject.value][triple.predicate.value] = triple.object.value ;\r\n        }\r\n\r\n        if(triple.object.value === \"http://www.w3.org/ns/hydra/core#PagedCollection\"){\r\n            currentPage = triple.subject.value;\r\n        }\r\n\r\n        if(currentPage !== undefined && triple.subject.value === currentPage){\r\n            if(triple.predicate.value === \"http://www.w3.org/ns/hydra/core#lastPage\"){\r\n                lastPage = triple.object.value;\r\n            }\r\n            if(triple.predicate.value === \"http://www.w3.org/ns/hydra/core#nextPage\"){\r\n                nextPage = triple.object.value;\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        dataSets: dataSets,\r\n        distributions: distributions,\r\n        currentPage: currentPage,\r\n        nextPage: nextPage,\r\n        lastPage: lastPage\r\n    };\r\n}\r\n\r\nexport async function getDataSetsFromStore(_store,keywords=[]){\r\n    let dataSets = {};\r\n    let distributions = {};\r\n    let distributionsData = {};\r\n    let locationIDtoDataSet = {};\r\n    let geometries = {};\r\n    let tags = {};\r\n    let pagingInfo = {};\r\n\r\n    await Promise.all([\r\n        getDataSets(_store).then((d)=>{dataSets=d}),\r\n        getDistributions(_store).then((d)=>{distributions=d.distributions; distributionsData=d.distributionsData}),\r\n        getLocationIDtoDataSet(_store).then((d)=>{locationIDtoDataSet=d}),\r\n        getGeometries(_store).then((d)=>{geometries=d}),\r\n        getKeywords(_store).then((d)=>{tags=d}),\r\n        getPagingInfo(_store).then((d)=>{pagingInfo=d})\r\n    ]);\r\n\r\n    for(let key in dataSets){\r\n        if(dataSets.hasOwnProperty(key)){\r\n            dataSets[key].distribution = distributions[key];\r\n            dataSets[key].geojson = geometries[locationIDtoDataSet[key]];\r\n            dataSets[key].keywords = tags[key];\r\n            if(keywords !== undefined){\r\n                for(let i=0;i<tags[key].length;i++){\r\n                    if(keywords.length === 0 || keywords.includes(tags[key][i])){\r\n                        dataSets[key].hasValidKeyword = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        dataSets: dataSets,\r\n        distributions: distributionsData,\r\n        currentPage: pagingInfo.currentPage,\r\n        nextPage: pagingInfo.nextPage,\r\n        lastPage: pagingInfo.lastPage\r\n    };\r\n}","import ldfetch from 'ldfetch';\r\nimport {getDataSetsFromTriples} from \"./Data\";\r\n\r\nexport function fetchCatalog(catalogUrl){\r\n    return new Promise((resolve) => {\r\n        let fetch = new ldfetch({headers: {accept: 'application/rdf+xml'}});\r\n        fetch.get(catalogUrl).then(\r\n            response => {resolve(response)}\r\n        )\r\n    });\r\n}\r\n\r\n//todo: fetching a lot of pages is really slow\r\nexport function fetchNextPage(res,catalog,tags=[],options){\r\n    return new Promise(resolve=>{\r\n        let t1 = performance.now();\r\n        fetchCatalog(((options && options.uriPrefix)?options.uriPrefix:\"\")+res.nextPage).then((c)=>{\r\n            let t2 = performance.now();\r\n            let sets = getDataSetsFromTriples(c.triples,tags);\r\n            let r = catalog.addCatalogPage(sets);\r\n            let t3 = performance.now();\r\n            if(options && options.logging){\r\n                console.log(\"page downloaded in\",t2-t1,\"ms\",\"and parsed in\",t3-t2,\"ms\");\r\n            }\r\n            resolve(r);\r\n        });\r\n    }).then((r2)=>{\r\n        return (r2.currentPage !== r2.lastPage) ? fetchNextPage(r2,catalog,tags,options) : r2;\r\n    });\r\n}\r\n\r\n\r\n","import axios from \"axios\";\r\n\r\nexport function download(_uri){\r\n    return new Promise((resolve,reject) => {\r\n        axios.get(_uri)\r\n            .then(response => resolve(response.data))\r\n            .catch(error => reject(error));\r\n    });\r\n}","/*\r\nhelper function to get [[lat,long],[lat,long],[lat,long]] from \"LINESTRING ( lat long, lat long, lat long )\"\r\n */\r\n\r\nexport default function (linestring){\r\n    let result = [];\r\n    let regex = /\\d*\\.\\d*/g;\r\n    let numbers = linestring.match(regex);\r\n\r\n    let lat = 0;\r\n    let i = 0;\r\n    numbers.forEach((number) => {\r\n        if(i % 2 === 0){\r\n            lat = parseFloat(number);\r\n        }\r\n        else {\r\n            result.push([lat, parseFloat(number)]);\r\n        }\r\n        i = (i + 1) % 2;\r\n    });\r\n\r\n    return result;\r\n}","import distance from '@turf/distance';\r\nimport {point} from '@turf/helpers'\r\n\r\nexport function calcDistance(lat1,long1,lat2,long2) {\r\n    let from = point([\r\n        long1,\r\n        lat1\r\n    ]);\r\n    let to = point([\r\n        long2,\r\n        lat2\r\n    ]);\r\n    return distance(from,to,{units: \"meters\"})\r\n}","import n3 from 'n3';\r\nimport linestringToLatLng from \"./linestringToLatLng\";\r\nimport {calcDistance} from \"./GeoFunctions\";\r\n\r\nconst { DataFactory } = n3;\r\nconst { namedNode } = DataFactory;\r\n\r\nexport function parseAndStoreQuads(_doc){\r\n    return new Promise(resolve => {\r\n        const parser = new n3.Parser();\r\n        const store = new n3.Store();\r\n        parser.parse(_doc, (error, quad, prefixes) => {\r\n            if(quad)\r\n                store.addQuad(quad);\r\n            else\r\n                resolve(store);\r\n        })\r\n    });\r\n}\r\n\r\nexport async function getSignalGroups(_store){\r\n    let signalgroups = [];\r\n    await _store\r\n        .getQuads(null, namedNode('http://www.w3.org/2000/01/rdf-schema#type'), namedNode('https://w3id.org/opentrafficlights#Signalgroup'))\r\n        .forEach(\r\n            (quad) => {signalgroups.push(quad.subject.value);}\r\n        );\r\n    return signalgroups;\r\n}\r\n\r\nexport async function getLaneDefs(_store){ //map linestring op lane\r\n    let lanes = {};\r\n    await _store\r\n        .getQuads(null, \"http://www.opengis.net/#geosparql/wktLiteral\", null)\r\n        .forEach(\r\n            (quad) => {lanes[quad.subject.value] = quad.object.value;}\r\n        );\r\n    return lanes;\r\n}\r\n\r\nexport async function getStateDefs(_store){ //map state op signalgroup\r\n    let greenStates = {};\r\n    await _store\r\n        .getQuads(null, \"https://w3id.org/opentrafficlights#signalState\", null)\r\n        .forEach(\r\n            (quad) => {greenStates[quad.object.value] = quad.subject.value;}\r\n        );\r\n    return greenStates;\r\n}\r\n\r\nexport async function getGreenStates(_store){ //phase 6\r\n    let greenStates = [];\r\n    await _store\r\n        .getQuads(null, \"https://w3id.org/opentrafficlights#signalPhase\", \"https://w3id.org/opentrafficlights/thesauri/signalphase/6\")\r\n        .forEach(\r\n            (quad) => {greenStates.push(quad.subject.value);}\r\n        );\r\n    return greenStates;\r\n}\r\n\r\nexport function getDepartureLanes(_store){\r\n    let departurelanes = [];\r\n    if(_store){\r\n        let processedDepartureLanes = [];\r\n        _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#departureLane'), null).forEach((quad) => {\r\n            _store.getQuads(quad.object, namedNode('http://purl.org/dc/terms/description'), null).forEach( (quad) => {\r\n                if (!processedDepartureLanes.includes(quad.object.value)){\r\n                    processedDepartureLanes.push(quad.object.value);\r\n                }\r\n\r\n                // Load arrival lanes\r\n                _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#departureLane'), quad.subject).forEach((connectie) => {\r\n                    let signalgroup = _store.getQuads(connectie.subject, namedNode('https://w3id.org/opentrafficlights#signalGroup'), null)[0].object.value;\r\n                    _store.getQuads(connectie.subject, namedNode('https://w3id.org/opentrafficlights#arrivalLane'), null).forEach( (arrivalLane) => {\r\n                        _store.getQuads(arrivalLane.object, namedNode('http://purl.org/dc/terms/description'), null).forEach( (descr) => {\r\n                            if(!departurelanes[quad.subject.value]) departurelanes[quad.subject.value] = [];\r\n                            departurelanes[quad.subject.value][arrivalLane.object.value] = {\r\n                                '@id': arrivalLane.object.value,\r\n                                'http://purl.org/dc/terms/description': descr.object.value,\r\n                                'https://w3id.org/opentrafficlights#signalGroup': signalgroup\r\n                            };\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    return departurelanes;\r\n}\r\n\r\nexport function getLanesForSignalGroup(_store){ //build index which gives an array of arrival lanes and an array of departure lanes for each signalgroup\r\n    return new Promise((resolve)=>{\r\n        let signalGroups = {};\r\n        if(_store) {\r\n            _store.getQuads(null, namedNode('http://www.w3.org/2000/01/rdf-schema#type'), namedNode('https://w3id.org/opentrafficlights#Signalgroup')).forEach((signalGroup) => {\r\n                if(!signalGroups[signalGroup.subject.value]){\r\n                    signalGroups[signalGroup.subject.value] = {departureLanes: [], arrivalLanes: []};\r\n                }\r\n\r\n                _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#signalGroup'), signalGroup.subject).forEach((connection) => {\r\n\r\n                    //Load departure lanes\r\n                    _store.getQuads(connection.subject, namedNode('https://w3id.org/opentrafficlights#departureLane'), null).forEach((quad) => {\r\n                        if(!signalGroups[connection.object.value].departureLanes.includes(quad.object.value)) signalGroups[connection.object.value].departureLanes.push(quad.object.value);\r\n                    });\r\n\r\n                    //Load arrival lanes\r\n                    _store.getQuads(connection.subject, namedNode('https://w3id.org/opentrafficlights#arrivalLane'), null).forEach((quad) => {\r\n                        if(!signalGroups[connection.object.value].arrivalLanes.includes(quad.object.value)) signalGroups[connection.object.value].arrivalLanes.push(quad.object.value);\r\n                    });\r\n\r\n                });\r\n            })\r\n        }\r\n        resolve(signalGroups);\r\n    });\r\n}\r\n\r\nexport function getLanesAsArrayInCorrectDirection(store){\r\n    return new Promise(resolve=>{\r\n        let lanes;\r\n        let startArrive;\r\n        Promise.all([\r\n            getLaneDefs(store).then((laneDefs)=>{\r\n                lanes = laneDefs;\r\n            }),\r\n            getLanesForSignalGroup(store).then(lanesForSignalGroup=>{\r\n                startArrive = lanesForSignalGroup\r\n            })\r\n        ]).then(()=>{\r\n            for(let key in lanes){\r\n                if(lanes.hasOwnProperty(key)){\r\n                    lanes[key] = linestringToLatLng(lanes[key]);\r\n                }\r\n            }\r\n            let newLanes = {};\r\n            for(let key in startArrive){\r\n                if(startArrive.hasOwnProperty(key)){\r\n                    for(let i=0;i<startArrive[key].departureLanes.length;i++){\r\n                        for(let j=0;j<startArrive[key].arrivalLanes.length;j++){\r\n                            let departureLane = lanes[startArrive[key].departureLanes[i]].slice();\r\n                            let arrivalLane = lanes[startArrive[key].arrivalLanes[j]].slice();\r\n                            let depEndToArrStart = calcDistance(departureLane[departureLane.length-1][0],departureLane[departureLane.length-1][1],arrivalLane[0][0],arrivalLane[0][1]);\r\n                            let depEndToArrEnd = calcDistance(departureLane[departureLane.length-1][0],departureLane[departureLane.length-1][1],arrivalLane[arrivalLane.length-1][0],arrivalLane[arrivalLane.length-1][1]);\r\n                            let depStartToArrStart = calcDistance(departureLane[0][0],departureLane[0][1],arrivalLane[0][0],arrivalLane[0][1]);\r\n                            let depStartToArrEnd = calcDistance(departureLane[0][0],departureLane[0][1],arrivalLane[arrivalLane.length-1][0],arrivalLane[arrivalLane.length-1][1]);\r\n                            if(depEndToArrStart < depEndToArrEnd && depEndToArrStart < depStartToArrStart && depEndToArrStart < depStartToArrEnd){\r\n                                newLanes[startArrive[key].departureLanes[i]] = departureLane;\r\n                                newLanes[startArrive[key].arrivalLanes[j]] = arrivalLane;\r\n                            }\r\n                            else if(depEndToArrEnd < depEndToArrStart && depEndToArrEnd < depStartToArrStart && depEndToArrEnd < depStartToArrEnd){\r\n                                // reverse arrival lane\r\n                                newLanes[startArrive[key].departureLanes[i]] = departureLane;\r\n                                newLanes[startArrive[key].arrivalLanes[j]+\"_reversed\"] = arrivalLane.reverse();\r\n                            }\r\n                            else if(depStartToArrStart < depEndToArrEnd && depStartToArrStart < depEndToArrStart && depStartToArrStart < depStartToArrEnd){\r\n                                // reverse departure lane\r\n                                newLanes[startArrive[key].departureLanes[i]+\"_reversed\"] = departureLane.reverse();\r\n                                newLanes[startArrive[key].arrivalLanes[j]] = arrivalLane;\r\n                            }\r\n                            else if(depStartToArrEnd < depEndToArrEnd && depStartToArrEnd < depStartToArrStart && depStartToArrEnd < depEndToArrStart){\r\n                                // reverse both arrival and departure lane\r\n                                newLanes[startArrive[key].departureLanes[i]+\"_reversed\"] = departureLane.reverse();\r\n                                newLanes[startArrive[key].arrivalLanes[j]+\"_reversed\"] = arrivalLane.reverse();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            resolve(newLanes);\r\n        });\r\n    });\r\n}","import MapDataBase from \"../utils/Integration/OpenLR/map/MapDataBase\";\r\nimport Catalog from \"../utils/Discovery/TrafficLightDataDiscovery/Catalog\";\r\nimport {getTileXYForLocation, tile2boundingBox} from \"../Logic/tileUtils\";\r\nimport {fetchRoutableTile} from \"../utils/Integration/Data/LoadData\";\r\nimport {getRoutableTilesNodesAndLines} from \"../utils/Integration/Data/ParseData\";\r\nimport RoutableTilesIntegration from \"../utils/Integration/OpenLRIntegration/RoutableTilesIntegration\";\r\nimport {fetchCatalog, fetchNextPage} from \"../utils/Discovery/TrafficLightDataDiscovery/Api\";\r\nimport {CATALOG_URL} from \"../utils/Discovery/TrafficLightDataDiscovery/Config\";\r\nimport * as React from \"react\";\r\nimport TileView from \"./TileView\";\r\nimport {getDataSetsFromStore, getDataSetsFromTriples} from \"../utils/Discovery/TrafficLightDataDiscovery/Data\";\r\nimport {download} from \"../utils/download\";\r\nimport {parseAndStoreQuads} from \"../utils/Discovery/TrafficLightDataDiscovery/Parser\";\r\nimport {Circle, GeoJSON, Polyline, Popup} from \"react-leaflet\";\r\nimport {downloadOpenTrafficLightsTestData} from \"../utils/OpenTrafficLights/data\";\r\nimport {getLaneDefs, getLanesAsArrayInCorrectDirection} from \"../utils/OpenTrafficLights/parser\";\r\nimport linestringToLatLng from \"../utils/OpenTrafficLights/linestringToLatLng\";\r\nimport Line from \"../utils/Integration/OpenLR/map/Line\";\r\nimport Node from \"../utils/Integration/OpenLR/map/Node\";\r\nimport {LinesDirectlyToLRPs} from \"../utils/Integration/OpenLR/experimental/LinesDirectlyToLRPs\";\r\nimport OpenLRDecoder from \"../utils/Integration/OpenLR/Decoder\";\r\nimport {configProperties, decoderProperties} from \"../utils/Integration/OpenLR/coder/CoderSettings\";\r\nimport {internalPrecisionEnum} from \"../utils/Integration/OpenLR/map/Enum\";\r\nimport {mapNodesLinesToID} from \"../utils/Integration/OpenLR/test/Helperfunctions\";\r\nimport LineEncoder from \"../utils/Integration/OpenLR/coder/LineEncoder\";\r\n\r\nlet encodingStratEnum = {\r\n    \"OpenLrEncode\": \"OpenLr encode lines in database only existing of these lines, only first and last line wil remain.\" ,\r\n    \"LinesToLRPs\": \"Simply make every line an LRP directly, without checking all the encoding steps.\"\r\n};\r\n\r\nlet lineVisualisationEnum = {\r\n    \"RawLineStrings\": \"Show the LineStrings as present in the dataset.\",\r\n    \"MappedLineStrings\": \"Show the LineStrings mapped on the current mapDataBase\"\r\n};\r\n\r\nlet catalogEnum = {\r\n    \"vodap\": \"Vlaamse Open Data Portaal\",\r\n    \"verkeerslichtdata_catalog_ttl\": \"Custom catalog for traffic light data on https://github.com/kareldh/TrafficLightsCatalog\"\r\n};\r\n\r\nexport class MainDemo extends React.Component{\r\n    constructor() {\r\n        super();\r\n        this.location = {\r\n            lat: 51.21205,\r\n            lng: 4.39717\r\n        };\r\n        this.state = {\r\n            data: [],\r\n            tileXY: getTileXYForLocation(this.location.lat,this.location.lng,14),\r\n            encodingStrat: encodingStratEnum.OpenLrEncode,\r\n            lineVisualisation: lineVisualisationEnum.MappedLineStrings,\r\n            catalog: catalogEnum.verkeerslichtdata_catalog_ttl\r\n        };\r\n        this.key = 0;\r\n        this.mapDataBase = new MapDataBase();\r\n        this.tiles = {};\r\n        this.catalogInitialized = this.initCatalog();\r\n        this.dataBaseInitialized = new Promise(resolve => resolve(true));\r\n        this.setLocation = this.setLocation.bind(this);\r\n        this.mappedDataSets = {};\r\n        this.resetMap = this.resetMap.bind(this);\r\n        this.handleGeoJsonClick = this.handleGeoJsonClick.bind(this);\r\n        this.handleEncodingStratSelect = this.handleEncodingStratSelect.bind(this);\r\n        this.handleLineStringVisualisationSelect = this.handleLineStringVisualisationSelect.bind(this);\r\n        this.handleInternalPrecisionSelect = this.handleInternalPrecisionSelect.bind(this);\r\n        this.handleCatalogSelect = this.handleCatalogSelect.bind(this);\r\n    }\r\n\r\n    initCatalog(catalog){\r\n        this.catalog = new Catalog();\r\n        if(catalog === catalogEnum.vodap){\r\n            return new Promise(resolve=>{\r\n                let t1 = performance.now();\r\n                fetchCatalog(\"https://cors-anywhere.herokuapp.com/\"+CATALOG_URL).then((c)=>{\r\n                    let t3 = performance.now();\r\n                    let sets = getDataSetsFromTriples(c.triples,[\"Boring\"]);\r\n                    let res = this.catalog.addCatalogPage(sets);\r\n                    let t4 = performance.now();\r\n                    console.log(\"first catalog page downloaded in\",t3-t1,\"ms\",\"and parsed in\",t4-t3,\"ms\");\r\n                    fetchNextPage(res,this.catalog,[\"Boring\"],{uriPrefix: \"https://cors-anywhere.herokuapp.com/\", logging: true}).then(()=>{\r\n                        let t2 = performance.now();\r\n                        console.log(\"Catalog initialized in\",t2-t1,\"ms\");\r\n                        resolve();\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        else{\r\n            return new Promise(resolve=>{\r\n                let t1 = performance.now();\r\n                download(\"https://raw.githubusercontent.com/kareldh/TrafficLightsCatalog/master/verkeerslicht_catalog.ttl\").then((c)=>{\r\n                    let t3 = performance.now();\r\n                    console.log(\"Catalog downloaded in\",t3-t1,\"ms\");\r\n                    parseAndStoreQuads(c).then(store=>{\r\n                        getDataSetsFromStore(store,[\"verkeerslicht\"]).then(sets=>{\r\n                            let t2 = performance.now();\r\n                            let r = this.catalog.addCatalogPage(sets);\r\n                            console.log(\"Catalog initialized in\",t2-t1,\"ms\",\"(Of which parsing took\",t2-t3,\"ms)\");\r\n                            resolve(r);\r\n                        });\r\n                    })\r\n                })\r\n            });\r\n        }\r\n    }\r\n\r\n    addRoutableTileToMapDataBase(zoom,x,y){\r\n        return new Promise(resolve=>{\r\n            fetchRoutableTile(zoom, x, y)\r\n                .then((data) => {\r\n                    let t1 = performance.now();\r\n                    getRoutableTilesNodesAndLines(data.triples)\r\n                        .then((nodesAndLines) => {\r\n                            let nodesLines = RoutableTilesIntegration.getNodesLines(nodesAndLines.nodes, nodesAndLines.lines);\r\n                            this.mapDataBase.addData(nodesLines.lines, nodesLines.nodes);\r\n                            let t2 = performance.now();\r\n                            console.log(\"Parsed tile\",x,y,\"in\",t2-t1,\"ms\");\r\n                            this.tiles[x + \"_\" + y] = true;\r\n                            resolve();\r\n                        })\r\n                })\r\n        });\r\n    }\r\n\r\n    setLocation(latLong){\r\n        let {lat,lng} = latLong;\r\n        let tileXY = getTileXYForLocation(lat,lng,14);\r\n        this.setState({tileXY: tileXY});\r\n        let promises = [];\r\n        let t1 = performance.now();\r\n        this.dataBaseInitialized = new Promise(resolve=>{\r\n            for(let ix=tileXY.x-1;ix<=tileXY.x+1;ix++){\r\n                for(let iy=tileXY.y-1;iy<=tileXY.y+1;iy++){\r\n                    // if(!this.tiles[ix+\"_\"+iy]){\r\n                    // use this check if we only want to fetch each tile one time during the lifetime of this application\r\n                    // not using this check results in refilling the mapDataBase every time the location is set\r\n                        promises.push(this.addRoutableTileToMapDataBase(14,ix,iy));\r\n                    // }\r\n                }\r\n            }\r\n            Promise.all(promises).then(()=>{\r\n                let t2 = performance.now();\r\n                console.log(\"mapDataBase initialized in\",t2-t1,\"ms\");\r\n                resolve();\r\n            });\r\n        });\r\n\r\n        this.catalogInitialized.then(()=>{\r\n            let t1 = performance.now();\r\n            let boundingBox = tile2boundingBox(tileXY.x,tileXY.y,14);\r\n            console.log(boundingBox);\r\n            let datasets = this.catalog.getDataSetsInRange(boundingBox.latLower,boundingBox.latUpper,boundingBox.longLower,boundingBox.longUpper);\r\n            let t2 = performance.now();\r\n            console.log(\"\",datasets.length,\"datasets found in\",t2-t1,\"ms\",\"in catalog of\",this.catalog.getDatasetCount(),\"datasets\");\r\n            let featureCollection = {\r\n                \"type\": \"FeatureCollection\",\r\n                \"features\": []\r\n            };\r\n            datasets.forEach((dataset)=>{\r\n                featureCollection.features.push({\"type\": dataset.type, \"properties\": dataset.properties, \"geometry\": dataset.geometry});\r\n            });\r\n            this.addGeoJson(featureCollection);\r\n        })\r\n    }\r\n\r\n    addGeoJson(geojson){\r\n        this.key = (this.key+1)%2;\r\n        this.setState({\r\n            data: [<GeoJSON key = {this.key} data={geojson} onClick={this.handleGeoJsonClick} />]\r\n        })\r\n    }\r\n\r\n    render(){\r\n        let {lat,lng} = this.location;\r\n        let {data,tileXY} = this.state;\r\n        return <div>\r\n            <div>\r\n                <TileView zoom={14} lat={lat} lng={lng} data={data} onMouseClick={this.setLocation}/>\r\n            </div>\r\n            <select name={\"Catalog\"} value={this.state.catalog} onChange={this.handleCatalogSelect}>\r\n                <option value={catalogEnum.verkeerslichtdata_catalog_ttl}>verkeerslichtdata_catalog_ttl</option>\r\n                <option value={catalogEnum.vodap}>VODAP</option>\r\n            </select>\r\n            <select name={\"Encode strategy\"} value={this.state.encodingStrat} onChange={this.handleEncodingStratSelect}>\r\n                <option value={encodingStratEnum.OpenLrEncode}>OpenLrEncode</option>\r\n                <option value={encodingStratEnum.LinesToLRPs}>Lines to LRPs</option>\r\n            </select>\r\n            <select name={\"Internal algorithmic precision\"} value={this.state.internalPrecision} onChange={this.handleInternalPrecisionSelect}>\r\n                <option value={internalPrecisionEnum.CENTIMETER}>Centimeter</option>\r\n                <option value={internalPrecisionEnum.METER}>Meter</option>\r\n            </select>\r\n            <select name={\"DataSet LineString visualisation\"} value={this.state.internalPrecision} onChange={this.handleLineStringVisualisationSelect}>\r\n                <option value={lineVisualisationEnum.MappedLineStrings}>Mapped to MapDataBase</option>\r\n                <option value={lineVisualisationEnum.RawLineStrings}>Raw LineStrings</option>\r\n            </select>\r\n            <button onClick={this.resetMap}>Reset</button>\r\n            current Tile X value: {tileXY.x} | Tile Y value: {tileXY.y}\r\n        </div>;\r\n    }\r\n\r\n    handleGeoJsonClick(event){\r\n        event.originalEvent.view.L.DomEvent.stopPropagation(event);\r\n        let datasetFeature = event.sourceTarget.feature;\r\n        console.log(datasetFeature);\r\n        let url = datasetFeature.properties.distribution[\"http://www.w3.org/ns/dcat#accessURL\"];\r\n        console.log(url);\r\n        let data = [];\r\n        // downloadOpenTrafficLightsTestData().then(doc=>{\r\n        download(url).then(doc=>{\r\n            MainDemo._getTrafficLightData(doc).then(parsed=>{\r\n                if(this.state.lineVisualisation === lineVisualisationEnum.MappedLineStrings){\r\n                    let LRPs = MainDemo._toLRPs(parsed,this.state.en);\r\n                    this.mappedDataSets[datasetFeature.properties.id] = LRPs;\r\n                    this.dataBaseInitialized.then(()=>{\r\n                        let t1 = performance.now();\r\n                        LRPs.forEach(line=>{\r\n                            try{\r\n                                let decoded = OpenLRDecoder.decode(line.LRP,this.mapDataBase,decoderProperties);\r\n                                let lineData = MainDemo.createLineStringsOpenLrForLane(decoded.lines,decoded.posOffset,decoded.negOffset,line.lane);\r\n                                Array.prototype.push.apply(data,lineData);\r\n                            }\r\n                            catch(e){\r\n                                console.error(e);\r\n                            }\r\n                        });\r\n                        let t2 = performance.now();\r\n                        console.log(\"LRPs decoded in \",t2-t1,\"ms\");\r\n                        this.setState({data: data});\r\n                    });\r\n                }\r\n                else if(this.state.lineVisualisation === lineVisualisationEnum.RawLineStrings){\r\n                    let t1 = performance.now();\r\n                    Array.prototype.push.apply(data,MainDemo._createRawLineStrings(parsed));\r\n                    let t2 = performance.now();\r\n                    console.log(\"Raw lines drawn in \",t2-t1,\"ms\");\r\n                    this.setState({data: data});\r\n                }\r\n            });\r\n        })\r\n            .catch((e)=>{console.log(\"Could not download distribution:\",e)});\r\n    }\r\n\r\n    static _getTrafficLightData(doc){\r\n        return new Promise(resolve => {\r\n            parseAndStoreQuads(doc).then((store)=>{\r\n                getLanesAsArrayInCorrectDirection(store).then(lanes=>{\r\n                    resolve(lanes);\r\n                })\r\n            })\r\n        });\r\n    }\r\n\r\n    static _createRawLineStrings(parsed){\r\n        let data = [];\r\n        for(let k in parsed){\r\n            if(parsed.hasOwnProperty(k)){\r\n                data.push(<Polyline\r\n                    positions = {parsed[k]}\r\n                    key={k}\r\n                >\r\n                    <Popup>\r\n                        <p>{k}</p>\r\n                    </Popup>\r\n                </Polyline>);\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    static _toLRPs(parsed,encodingStrat){\r\n        let t1 = performance.now();\r\n        let LRPs = [];\r\n        for(let key in parsed){\r\n            if(parsed.hasOwnProperty(key)){\r\n                let n = [];\r\n                let l = [];\r\n                n.push(new Node(0,parsed[key][0][0],parsed[key][0][1]));\r\n                for(let i=1;i<parsed[key].length;i++){\r\n                    n.push(new Node(i,parsed[key][i][0],parsed[key][i][1]));\r\n                    l.push(new Line(i,n[i-1],n[i]));\r\n                }\r\n                if(encodingStrat === encodingStratEnum.LinesToLRPs){\r\n                    LRPs.push({\r\n                        lane: key,\r\n                        LRP: LinesDirectlyToLRPs(l)\r\n                    })\r\n                }\r\n                else{\r\n                    let {nodes,lines} = mapNodesLinesToID(n,l);\r\n                    let mapDataBase = new MapDataBase(lines,nodes);\r\n                    LRPs.push({\r\n                        lane: key,\r\n                        LRP: LineEncoder.encode(mapDataBase,l,0,0)\r\n                    })\r\n                }\r\n            }\r\n        }\r\n        let t2 = performance.now();\r\n        console.log(\"LineStrings encoded in\",t2-t1,\"ms\");\r\n        return LRPs;\r\n    }\r\n\r\n    static createLineStringsOpenLrForLane(lines, posOffset, negOffset, lane){\r\n        let lineStrings = [];\r\n        if(lines !== undefined){\r\n            for (let i=0;i<lines.length;i++) {\r\n                lineStrings.push(\r\n                    <Polyline\r\n                        positions = {[[lines[i].getStartNode().getLatitudeDeg(),lines[i].getStartNode().getLongitudeDeg()],[lines[i].getEndNode().getLatitudeDeg(),lines[i].getEndNode().getLongitudeDeg()]]}\r\n                        key={lines[i].getID()+lane}\r\n                        color={i%2===0?\"Blue\":\"DarkTurquoise \"}\r\n                    >\r\n                        <Popup>\r\n                            <p>{lines[i].getID()+\" -> \"+lane}</p>\r\n                        </Popup>\r\n                    </Polyline>);\r\n            }\r\n            let firstOffsetCoord = lines[0].getGeoCoordinateAlongLine(posOffset*configProperties.internalPrecision);\r\n            let lastOffsetCoord = lines[lines.length-1].getGeoCoordinateAlongLine(lines[lines.length-1].getLength()-(negOffset*configProperties.internalPrecision));\r\n            lineStrings.push(<Circle key={\"firstOffsetPoint\"+lane} center={[firstOffsetCoord.lat,firstOffsetCoord.long]} radius={1} color={\"red\"}>\r\n                <Popup>\r\n                    <p>Start {lane}</p>\r\n                </Popup>\r\n            </Circle>);\r\n            lineStrings.push(<Circle key={\"lastOffsetPoint\"+lane} center={[lastOffsetCoord.lat,lastOffsetCoord.long]} radius={1} color={\"magenta\"}>\r\n                <Popup>\r\n                    <p>End {lane}</p>\r\n                </Popup>\r\n            </Circle>);\r\n            return lineStrings;\r\n        }\r\n    }\r\n\r\n    resetMap(){\r\n        this.setState((state,props)=>{\r\n            return {\r\n                data: [],\r\n            }\r\n        });\r\n    }\r\n\r\n    handleInternalPrecisionSelect(event){\r\n        configProperties.internalPrecision = event.target.value;\r\n        this.mapDataBase = new MapDataBase();\r\n        this.setLocation(this.location);\r\n    }\r\n\r\n    handleEncodingStratSelect(event){\r\n        this.setState({encodingStrat: event.target.value});\r\n    }\r\n\r\n    handleLineStringVisualisationSelect(event){\r\n        this.setState({lineVisualisation: event.target.value});\r\n    }\r\n\r\n    handleCatalogSelect(event){\r\n        this.setState({catalog: event.target.value});\r\n        this.initCatalog(event.target.value);\r\n    }\r\n}","import React from 'react';\r\nimport TileView from \"./TileView\";\r\nimport {\r\n    filterHighwayData,\r\n    getMappedElements, getRoutableTilesNodesAndLines,\r\n    parseToJson\r\n} from \"../utils/Integration/Data/ParseData\";\r\nimport {Marker, Polyline, Popup, Circle} from \"react-leaflet\";\r\nimport {mapNodesLinesToID} from \"../utils/Integration/OpenLR/test/Helperfunctions\";\r\nimport OSMIntegration from \"../utils/Integration/OpenLRIntegration/OSMIntegration\";\r\nimport OpenLRDecoder from \"../utils/Integration/OpenLR/Decoder\";\r\nimport LineEncoder from \"../utils/Integration/OpenLR/coder/LineEncoder\";\r\nimport MapDataBase from \"../utils/Integration/OpenLR/map/MapDataBase\";\r\nimport Line from \"../utils/Integration/OpenLR/map/Line\";\r\nimport Node from \"../utils/Integration/OpenLR/map/Node\";\r\nimport RoutableTilesIntegration from \"../utils/Integration/OpenLRIntegration/RoutableTilesIntegration\";\r\nimport {\r\n    loadNodesLineStringsWegenregisterAntwerpen, fetchRoutableTile,\r\n    fetchOsmData\r\n} from \"../utils/Integration/Data/LoadData\";\r\nimport WegenregisterAntwerpenIntegration from \"../utils/Integration/OpenLRIntegration/WegenregisterAntwerpenIntegration\";\r\nimport GeoJsonIntegration from \"../utils/Integration/OpenLRIntegration/GeoJsonIntegration\";\r\nimport {map} from \"../utils/Integration/Data/testdata/junction_with_lanes_manual\";\r\n// import {map} from \"../utils/Integration/Data/testdata/lanes_from_data_with_correct_direction\";\r\n// import {map} from \"../utils/Integration/Data/testdata/lanes_manual_empty_junction_3\";\r\nimport {LinesDirectlyToLRPs} from \"../utils/Integration/OpenLR/experimental/LinesDirectlyToLRPs\";\r\nimport {configProperties, decoderProperties} from \"../utils/Integration/OpenLR/coder/CoderSettings\";\r\nimport {internalPrecisionEnum} from \"../utils/Integration/OpenLR/map/Enum\";\r\nimport {getTileXYForLocation, tile2boundingBox} from \"../Logic/tileUtils\";\r\nimport {downloadOpenTrafficLightsTestData} from \"../utils/OpenTrafficLights/data\";\r\nimport {MainDemo} from \"./MainDemo\";\r\n\r\nlet inputDataEnum = {\r\n    \"RoutableTiles\": \"RoutableTiles\",\r\n    \"OpenStreetMap\": \"OpenStreetMap\",\r\n    \"Wegenregister_Antwerpen\": \"Wegenregister_Antwerpen\",\r\n    \"Geojson_kruispunt_tropisch_instituut\": \"Geojson_kruispunt_tropisch_instituut\"\r\n};\r\n\r\nlet encodingStratEnum = {\r\n    \"OpenLrEncode\": \"OpenLr encode lines in database only existing of these lines, only first and last line wil remain.\" ,\r\n    \"LinesToLRPs\": \"Simply make every line an LRP directly, without checking all the encoding steps.\"\r\n};\r\n\r\nexport default class OpenLrDemo extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            data: [],\r\n            lat: 51.21205,\r\n            lng: 4.39717,\r\n            encodingStrat: encodingStratEnum.OpenLrEncode,\r\n            dataSource: inputDataEnum.RoutableTiles,\r\n            internalPrecision: internalPrecisionEnum.CENTIMETER\r\n        };\r\n        this.x = 8392;\r\n        this.y = 5469;\r\n        this.coordinates =[];\r\n        this.tiles = {};\r\n        this.addMarker = this.addMarker.bind(this);\r\n        this.reset = this.reset.bind(this);\r\n        this.findMarkersOsm = this.findMarkersOsm.bind(this);\r\n        this.findMarkersRoutableTiles = this.findMarkersRoutableTiles.bind(this);\r\n        this.findMarkers = this.findMarkers.bind(this);\r\n        this.handleEncodingStratSelect = this.handleEncodingStratSelect.bind(this);\r\n        this.handleDataSourceSelect = this.handleDataSourceSelect.bind(this);\r\n        this.addDataBases = this.addDataBases.bind(this);\r\n        this.handleInternalPrecisionSelect = this.handleInternalPrecisionSelect.bind(this);\r\n        this.showLanesAntwerpenTest = this.showLanesAntwerpenTest.bind(this);\r\n        this.osmDataBase = undefined;\r\n        this.routableTilesDataBase = undefined;\r\n        this.wegenregisterDataBase = undefined;\r\n        this.geojsonKruispuntDataBase = undefined;\r\n        this.dataBasesInitialized = new Promise((resolve,reject)=>resolve());\r\n        decoderProperties.useFrcFow = false;\r\n    }\r\n\r\n    static createMarker(latitude,longitude){\r\n         return <Marker key={latitude+\"_\"+longitude} position={[latitude, longitude]}>\r\n                <Popup>\r\n                    <p>{latitude+\" \"+longitude}</p>\r\n                </Popup>\r\n            </Marker>;\r\n    }\r\n\r\n    findMarkers(){\r\n        let {coordinates} = this;\r\n        if(coordinates.length >= 2){\r\n            let l = [];\r\n            let n = [];\r\n            n.push(new Node(0,coordinates[0].lat,coordinates[0].lng));\r\n            for(let i=1;i<coordinates.length;i++){\r\n                n.push(new Node(i,coordinates[i].lat,coordinates[i].lng));\r\n                l.push(new Line(i,n[i-1],n[i]));\r\n            }\r\n            let {nodes,lines} = mapNodesLinesToID(n,l);\r\n            let mapDataBase = new MapDataBase(lines,nodes);\r\n            let encoded;\r\n            if(this.state.encodingStrat === encodingStratEnum.OpenLrEncode){\r\n                encoded = LineEncoder.encode(mapDataBase,l,0,0);\r\n            }\r\n            else if(this.state.encodingStrat === encodingStratEnum.LinesToLRPs){\r\n                encoded = LinesDirectlyToLRPs(l);\r\n            }\r\n            console.log(encoded);\r\n\r\n            if(this.state.dataSource===inputDataEnum.OpenStreetMap){\r\n                this.findMarkersOsm(encoded);\r\n            }\r\n            else if(this.state.dataSource===inputDataEnum.RoutableTiles){\r\n                this.findMarkersRoutableTiles(encoded);\r\n            }\r\n            else if(this.state.dataSource===inputDataEnum.Wegenregister_Antwerpen){\r\n                this.findMarkersWegenregisterAntwerpen(encoded);\r\n            }\r\n            else if(this.state.dataSource===inputDataEnum.Geojson_kruispunt_tropisch_instituut){\r\n                this.findMarkersGeojsonKruispunt(encoded);\r\n            }\r\n        }\r\n        else{\r\n            console.log(\"Not enough coordinates given to form a line\",this.state.coordinates);\r\n        }\r\n    }\r\n\r\n    findMarkersOsm(encoded){\r\n        // if(this.osmDataBase === undefined){\r\n        //     loadOsmTestData()\r\n        //         .then((data)=>{parseToJson(data)\r\n        //             .then((json)=>{getMappedElements(json)\r\n        //                 .then((elements)=>{filterHighwayData(elements)\r\n        //                     .then((highwayData)=>{\r\n        //                         try {\r\n        //                             let t1 = performance.now();\r\n        //                             this.osmDataBase = new MapDataBase();\r\n        //                             OSMIntegration.initMapDataBase(this.osmDataBase,highwayData.nodes,highwayData.ways,highwayData.relations);\r\n        //                             let decoded = OpenLRDecoder.decode(encoded,this.osmDataBase,decoderProperties);\r\n        //                             let t2 = performance.now();\r\n        //                             console.log(\"Found in Open Street Maps in\",t2-t1,\"ms\",decoded);\r\n        //                             this.createLineStringsOpenLr(decoded.lines,decoded.posOffset,decoded.negOffset);\r\n        //                         }\r\n        //                         catch(e){\r\n        //                             alert(e);\r\n        //                         }\r\n        //                     })})})});\r\n        // }\r\n        // else{\r\n        this.dataBasesInitialized.then(()=>{\r\n            try{\r\n                let t1 = performance.now();\r\n                let decoded = OpenLRDecoder.decode(encoded,this.osmDataBase,decoderProperties);\r\n                let t2 = performance.now();\r\n                console.log(\"Found in Open Street Maps in\",t2-t1,\"ms\",decoded);\r\n                this.createLineStringsOpenLr(decoded.lines,decoded.posOffset,decoded.negOffset);\r\n            }\r\n            catch(e){\r\n                alert(e);\r\n            }\r\n        });\r\n        // }\r\n    }\r\n\r\n    findMarkersRoutableTiles(encoded){\r\n        // if(this.routableTilesDataBase === undefined){\r\n        //     fetchRoutableTile(14,this.x,this.y)\r\n        //         .then((data)=>{getRoutableTilesNodesAndLines(data.triples)\r\n        //             .then((nodesAndLines)=>{\r\n        //                 try{\r\n        //                     let t1 = performance.now();\r\n        //                     this.routableTilesDataBase = new MapDataBase();\r\n        //                     RoutableTilesIntegration.initMapDataBase(this.routableTilesDataBase,nodesAndLines.nodes,nodesAndLines.lines);\r\n        //                     let decoded = OpenLRDecoder.decode(encoded,this.routableTilesDataBase,decoderProperties);\r\n        //                     let t2 = performance.now();\r\n        //                     console.log(\"Found in RoutableTiles in\",t2-t1,\"ms\",decoded);\r\n        //                     this.createLineStringsOpenLr(decoded.lines,decoded.posOffset,decoded.negOffset);\r\n        //                 }\r\n        //                 catch(e){\r\n        //                     alert(e);\r\n        //                 }\r\n        //             })});\r\n        // }\r\n        // else{\r\n        this.dataBasesInitialized.then(()=>{\r\n            try{\r\n                let t1 = performance.now();\r\n                let decoded = OpenLRDecoder.decode(encoded,this.routableTilesDataBase,decoderProperties);\r\n                let t2 = performance.now();\r\n                console.log(\"Found in RoutableTiles in\",t2-t1,\"ms\",decoded);\r\n                this.createLineStringsOpenLr(decoded.lines,decoded.posOffset,decoded.negOffset);\r\n            }\r\n            catch(e){\r\n                alert(e);\r\n            }\r\n        });\r\n        // }\r\n    }\r\n\r\n    findMarkersWegenregisterAntwerpen(encoded){\r\n        if(this.wegenregisterDataBase === undefined){\r\n            loadNodesLineStringsWegenregisterAntwerpen().then(features => {\r\n                try{\r\n                    this.wegenregisterDataBase = new MapDataBase();\r\n                    let t1 = performance.now();\r\n                    WegenregisterAntwerpenIntegration.initMapDataBase(this.wegenregisterDataBase,features);\r\n                    let decoded = OpenLRDecoder.decode(encoded,this.wegenregisterDataBase,decoderProperties);\r\n                    let t2 = performance.now();\r\n                    console.log(\"Found in Wegenregister Antwerpen in\",t2-t1,\"ms\",decoded);\r\n                    this.createLineStringsOpenLr(decoded.lines,decoded.posOffset,decoded.negOffset);\r\n                }\r\n                catch(e){\r\n                    alert(e);\r\n                }\r\n            });\r\n        }\r\n        else{\r\n            try{\r\n                let t1 = performance.now();\r\n                let decoded = OpenLRDecoder.decode(encoded,this.wegenregisterDataBase,decoderProperties);\r\n                let t2 = performance.now();\r\n                console.log(\"Found in Wegenregister Antwerpen in\",t2-t1,\"ms\",decoded);\r\n                this.createLineStringsOpenLr(decoded.lines,decoded.posOffset,decoded.negOffset);\r\n            }\r\n            catch(e){\r\n                alert(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    findMarkersGeojsonKruispunt(encoded){\r\n        if(this.geojsonKruispuntDataBase === undefined){\r\n            try{\r\n                let t1 = performance.now();\r\n                this.geojsonKruispuntDataBase = new MapDataBase();\r\n                GeoJsonIntegration.initMapDataBase(this.geojsonKruispuntDataBase,map.features);\r\n                let decoded = OpenLRDecoder.decode(encoded,this.geojsonKruispuntDataBase,decoderProperties);\r\n                let t2 = performance.now();\r\n                console.log(\"Found in Geojson kruispunt in\",t2-t1,\"ms\",decoded);\r\n                this.createLineStringsOpenLr(decoded.lines,decoded.posOffset,decoded.negOffset);\r\n            }\r\n            catch(e){\r\n                alert(e);\r\n            }\r\n        }\r\n        else{\r\n            try{\r\n                let t1 = performance.now();\r\n                let decoded = OpenLRDecoder.decode(encoded,this.geojsonKruispuntDataBase,decoderProperties);\r\n                let t2 = performance.now();\r\n                console.log(\"Found in Geojson kruispunt in\",t2-t1,\"ms\",decoded);\r\n                this.createLineStringsOpenLr(decoded.lines,decoded.posOffset,decoded.negOffset);\r\n            }\r\n            catch(e){\r\n                alert(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    addMarker(latlng){\r\n        this.addDataBases(latlng,this.state.dataSource);\r\n        this.coordinates.push(latlng);\r\n        // let marker = OpenLrDemo.createMarker(latlng.lat,latlng.lng);\r\n        this.setState(()=>{\r\n            let d = this.coordinates.map((c)=>{\r\n                    return OpenLrDemo.createMarker(c.lat,c.lng);\r\n                });\r\n            return {\r\n                data: d,\r\n            }\r\n        });\r\n    }\r\n\r\n    addDataBases(latlng,dataSource){\r\n        let {lat,lng} = latlng;\r\n        let tileXY = getTileXYForLocation(lat,lng,14);\r\n        this.x = tileXY.x;\r\n        this.y = tileXY.y;\r\n        let promises = [];\r\n        let t1 = performance.now();\r\n        let promise = new Promise(resolve=>{\r\n            for(let ix=tileXY.x-1;ix<=tileXY.x+1;ix++){\r\n                for(let iy=tileXY.y-1;iy<=tileXY.y+1;iy++){\r\n                    if(!this.tiles[ix+\"_\"+iy]){\r\n                        // use this check if we only want to fetch each tile one time during the lifetime of this application\r\n                        // not using this check results in refilling the mapDataBase every time the location is set\r\n                        if(dataSource===inputDataEnum.RoutableTiles){\r\n                            promises.push(this.addRoutableTileToMapDataBase(14,ix,iy));\r\n                        }\r\n                        else if(dataSource===inputDataEnum.OpenStreetMap){\r\n                            promises.push(this.addOpenStreetMapTileToMapDataBase(14,ix,iy));\r\n                        }\r\n                        this.tiles[ix+\"_\"+iy] = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            Promise.all(promises).then(()=>{\r\n                let t2 = performance.now();\r\n                console.log(\"mapDataBase initialized in\",t2-t1,\"ms\");\r\n                resolve();\r\n            }).catch();\r\n        });\r\n        this.dataBasesInitialized = Promise.all([\r\n           this.dataBasesInitialized,\r\n           promise\r\n        ]);\r\n    }\r\n\r\n    addRoutableTileToMapDataBase(zoom,x,y){\r\n        let t3 = performance.now();\r\n        return new Promise((resolve,reject)=>{\r\n            fetchRoutableTile(zoom, x, y)\r\n                .then((data) => {\r\n                    let t4 = performance.now();\r\n                    console.log(\"downloaded tile\",x,y,zoom,\"in\",t4-t3,\"ms\");\r\n                    let t1 = performance.now();\r\n                    getRoutableTilesNodesAndLines(data.triples)\r\n                        .then((nodesAndLines) => {\r\n                            if(this.routableTilesDataBase === undefined){\r\n                                this.routableTilesDataBase = new MapDataBase();\r\n                            }\r\n                            let nodesLines = RoutableTilesIntegration.getNodesLines(nodesAndLines.nodes, nodesAndLines.lines);\r\n                            this.routableTilesDataBase.addData(nodesLines.lines, nodesLines.nodes);\r\n                            let t2 = performance.now();\r\n                            console.log(\"parsed tile\",x,y,zoom,\"in\",t2-t1,\"ms\");\r\n                            resolve();\r\n                        })\r\n                })\r\n                .catch((e)=>reject(e));\r\n        });\r\n    }\r\n\r\n    addOpenStreetMapTileToMapDataBase(zoom,x,y){\r\n        let boundingBox = tile2boundingBox(x,y,zoom);\r\n        let t3 = performance.now();\r\n        return new Promise((resolve,reject)=>{\r\n            fetchOsmData(boundingBox.latLower,boundingBox.latUpper,boundingBox.longLower,boundingBox.longUpper)\r\n                .then((data)=>{\r\n                    let t4 = performance.now();\r\n                    console.log(\"downloaded tile\",x,y,zoom,\"in\",t4-t3,\"ms\");\r\n                    let t1 = performance.now();\r\n                    parseToJson(data)\r\n                    .then((json)=>{getMappedElements(json)\r\n                        .then((elements)=>{filterHighwayData(elements)\r\n                            .then((highwayData)=>{\r\n                                if(this.osmDataBase === undefined){\r\n                                    this.osmDataBase = new MapDataBase();\r\n                                }\r\n                                let nodesLines = OSMIntegration.getNodesLines(highwayData.nodes,highwayData.ways,highwayData.relations);\r\n                                this.osmDataBase.addData(nodesLines.lines,nodesLines.nodes);\r\n                                let t2 = performance.now();\r\n                                console.log(\"parsed tile\",x,y,zoom,\"in\",t2-t1,\"ms\");\r\n                                resolve();\r\n                            })})})})\r\n                .catch(e=>reject(e));\r\n        });\r\n\r\n    }\r\n\r\n    createLineStringsOpenLr(lines,posOffset,negOffset){\r\n        // let lat = 51.21205;\r\n        // let lng = 4.39717;\r\n        let lineStrings = [];\r\n        if(lines !== undefined){\r\n            for (let i=0;i<lines.length;i++) {\r\n                lineStrings.push(OpenLrDemo.createPolyline(lines[i],i));\r\n            }\r\n            let firstOffsetCoord = lines[0].getGeoCoordinateAlongLine(posOffset*configProperties.internalPrecision);\r\n            let lastOffsetCoord = lines[lines.length-1].getGeoCoordinateAlongLine(lines[lines.length-1].getLength()-(negOffset*configProperties.internalPrecision));\r\n            lineStrings.push(<Circle key={\"firstOffsetPoint\"} center={[firstOffsetCoord.lat,firstOffsetCoord.long]} radius={1} color={\"red\"}/>);\r\n            lineStrings.push(<Circle key={\"lastOffsetPoint\"} center={[lastOffsetCoord.lat,lastOffsetCoord.long]} radius={1} color={\"magenta\"}/>);\r\n            this.setState({data: lineStrings});\r\n        }\r\n    }\r\n\r\n    static createPolyline(line,seq){\r\n        return <Polyline\r\n            positions = {[[line.getStartNode().getLatitudeDeg(),line.getStartNode().getLongitudeDeg()],[line.getEndNode().getLatitudeDeg(),line.getEndNode().getLongitudeDeg()]]}\r\n            key={line.getID()}\r\n            color={seq%2===0?\"Blue\":\"DarkTurquoise \"}\r\n        >\r\n            <Popup>\r\n                <p>{line.getID()}</p>\r\n            </Popup>\r\n        </Polyline>;\r\n    }\r\n\r\n    reset(){\r\n        this.setState((state)=>{\r\n            return {\r\n                data: [],\r\n                coordinates: [],\r\n                lat: state.lat,\r\n                lng: state.lng,\r\n            }\r\n        });\r\n        this.coordinates =[];\r\n    }\r\n\r\n    render(){\r\n        let {data,lat,lng} = this.state;\r\n        console.log(data);\r\n        return <div>\r\n            <div>\r\n                <TileView zoom={14} lat={lat} lng={lng} data={data} onMouseClick={this.addMarker}/>\r\n            </div>\r\n            <select name={\"Datasource\"} value={this.state.dataSource} onChange={this.handleDataSourceSelect}>\r\n                <option value={inputDataEnum.RoutableTiles}>Routable Tiles data</option>\r\n                <option value={inputDataEnum.OpenStreetMap}>Open Street Map data</option>\r\n                <option value={inputDataEnum.Wegenregister_Antwerpen}>Wegenregister Antwerpen data</option>\r\n                <option value={inputDataEnum.Geojson_kruispunt_tropisch_instituut}>Geojson kruispunt tropisch instituut Antwerpen data</option>\r\n            </select>\r\n            <select name={\"Encode strategy\"} value={this.state.encodingStrat} onChange={this.handleEncodingStratSelect}>\r\n                <option value={encodingStratEnum.OpenLrEncode}>OpenLrEncode</option>\r\n                <option value={encodingStratEnum.LinesToLRPs}>Lines to LRPs</option>\r\n            </select>\r\n            <select name={\"Internal algorithmic precision\"} value={this.state.internalPrecision} onChange={this.handleInternalPrecisionSelect}>\r\n                <option value={internalPrecisionEnum.CENTIMETER}>Centimeter</option>\r\n                <option value={internalPrecisionEnum.METER}>Meter</option>\r\n            </select>\r\n            <button onClick={this.findMarkers}>Find lines in data</button>\r\n            <button onClick={this.reset}>Reset</button>\r\n            <button onClick={this.showLanesAntwerpenTest}>Demo kruispunt</button>\r\n            current tile x value: {this.x}   current tile y value: {this.y}\r\n        </div>;\r\n    }\r\n\r\n    handleEncodingStratSelect(event){\r\n        this.setState({encodingStrat: event.target.value});\r\n    }\r\n\r\n    handleDataSourceSelect(event){\r\n        this.setState({dataSource: event.target.value});\r\n        this.tiles = [];\r\n    }\r\n\r\n    handleInternalPrecisionSelect(event){\r\n        this.osmDataBase = undefined;\r\n        this.routableTilesDataBase = undefined;\r\n        this.wegenregisterDataBase = undefined;\r\n        this.geojsonKruispuntDataBase = undefined;\r\n        this.tiles = [];\r\n        configProperties.internalPrecision = event.target.value*1;\r\n        this.setState({internalPrecision: event.target.value*1});\r\n        this.reset();\r\n    }\r\n\r\n    showLanesAntwerpenTest(){\r\n        let data = [];\r\n        let database = undefined;\r\n        let dataBaseInitialized = new Promise((resolve)=>resolve());\r\n        if(this.state.dataSource===inputDataEnum.Wegenregister_Antwerpen){\r\n            if(this.wegenregisterDataBase === undefined){\r\n                dataBaseInitialized = new Promise(resolve=>{\r\n                    let t3 = performance.now();\r\n                    loadNodesLineStringsWegenregisterAntwerpen().then(features => {\r\n                        let t4 = performance.now();\r\n                        console.log(\"Wegenregister downloaded in\",t4-t3,\"ms\");\r\n                        try{\r\n                            let t1 = performance.now();\r\n                            this.wegenregisterDataBase = new MapDataBase();\r\n                            WegenregisterAntwerpenIntegration.initMapDataBase(this.wegenregisterDataBase,features);\r\n                            let t2 = performance.now();\r\n                            console.log(\"Wegenregister parsed in\",t2-t1,\"ms\");\r\n                            console.log(\"Wegenregister initialised in\",t2-t3);\r\n                            resolve();\r\n                        }\r\n                        catch(e){\r\n                            alert(e);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        else if(this.state.dataSource===inputDataEnum.Geojson_kruispunt_tropisch_instituut){\r\n            if(this.geojsonKruispuntDataBase === undefined){\r\n                this.geojsonKruispuntDataBase = new MapDataBase();\r\n                GeoJsonIntegration.initMapDataBase(this.geojsonKruispuntDataBase,map.features);\r\n            }\r\n        }\r\n        else{\r\n            this.addDataBases({lat: 51.21205, lng: 4.39717},this.state.dataSource);\r\n            dataBaseInitialized = this.dataBasesInitialized;\r\n        }\r\n        console.log(dataBaseInitialized);\r\n        downloadOpenTrafficLightsTestData().then(doc=>{\r\n            MainDemo._getTrafficLightData(doc).then(parsed=> {\r\n                let LRPs = MainDemo._toLRPs(parsed,this.state.encodingStrat);\r\n                dataBaseInitialized.then(() => {\r\n                    console.log(dataBaseInitialized);\r\n                    if(this.state.dataSource===inputDataEnum.OpenStreetMap){\r\n                        database = this.osmDataBase;\r\n                    }\r\n                    else if(this.state.dataSource===inputDataEnum.RoutableTiles){\r\n                        database = this.routableTilesDataBase;\r\n                    }\r\n                    else if(this.state.dataSource===inputDataEnum.Wegenregister_Antwerpen){\r\n                        database = this.wegenregisterDataBase;\r\n                    }\r\n                    else if(this.state.dataSource===inputDataEnum.Geojson_kruispunt_tropisch_instituut){\r\n                        database = this.geojsonKruispuntDataBase;\r\n                    }\r\n                    console.log(\"Lines in target database:\",Object.keys(database.lines).length);\r\n                    let t1 = performance.now();\r\n                    LRPs.forEach(line => {\r\n                        try {\r\n                            let decoded = OpenLRDecoder.decode(line.LRP, database, decoderProperties);\r\n                            console.log(\"Line:\",line,\"Decoded:\",decoded);\r\n                            let lineData = MainDemo.createLineStringsOpenLrForLane(decoded.lines, decoded.posOffset, decoded.negOffset, line.lane);\r\n                            Array.prototype.push.apply(data, lineData);\r\n                        }\r\n                        catch (e) {\r\n                            console.error(e);\r\n                        }\r\n                    });\r\n                    let t2 = performance.now();\r\n                    console.log(\"LRPs decoded in \", t2 - t1, \"ms\");\r\n                    this.setState({data: data});\r\n                })\r\n                    .catch(e=>{\r\n                        this.osmDataBase = undefined;\r\n                        this.routableTilesDataBase = undefined;\r\n                        this.wegenregisterDataBase = undefined;\r\n                        this.geojsonKruispuntDataBase = undefined;\r\n                        this.tiles = [];\r\n                        this.dataBasesInitialized = new Promise((resolve,reject)=>resolve());\r\n                        alert(e);\r\n                    });\r\n            })});\r\n    }\r\n}","import ldfetch from \"ldfetch\";\r\nimport {data} from \"./testdata/latest\"\r\nimport axios from 'axios';\r\n\r\nexport function getOpenTrafficLightsData(URL){\r\n    return new Promise((resolve) => {\r\n        let fetch = new ldfetch({headers: {accept: 'application/rdf+xml'}});\r\n        fetch.get(URL).then(\r\n            response => {resolve(response)}\r\n        )\r\n    });\r\n}\r\n\r\nexport function downloadOpenTrafficLightsTestData(){\r\n    return new Promise((resolve)=>resolve(data));\r\n}","import React from 'react'\r\nimport { Menu } from 'semantic-ui-react'\r\nimport { Link } from 'react-router-dom'\r\n\r\nclass NavBar extends React.Component {\r\n    state = {};\r\n\r\n    handleItemClick = (e, { name }) =>\r\n        this.setState({ activeItem: name });\r\n\r\n    render() {\r\n        const { activeItem } = this.state;\r\n        return (\r\n            <Menu>\r\n                <Menu.Item\r\n                    as={Link} to={'/OpenLRDemo/'}\r\n                    name='OpenLRDemo'\r\n                    active={activeItem === 'OpenLRDemo'}\r\n                    onClick={this.handleItemClick}\r\n                >\r\n                    OpenLR demo page\r\n                </Menu.Item>\r\n                <Menu.Item\r\n                    as={Link} to={'/DiscoveryDemo/'}\r\n                    name='DiscoveryDemo'\r\n                    active={activeItem === 'DiscoveryDemo'}\r\n                    onClick={this.handleItemClick}\r\n                >\r\n                    Dataset discovery demo page\r\n                </Menu.Item>\r\n            </Menu>\r\n        )\r\n    }\r\n}\r\n\r\nexport default NavBar","import React, {Component} from 'react';\r\nimport {HashRouter as Router, Route} from \"react-router-dom\";\r\nimport './App.css';\r\n// import ApiContainer from \"./components/ApiContainer\";\r\nimport OpenLrDemo from \"./components/OpenLrDemo\";\r\nimport {MainDemo} from \"./components/MainDemo\";\r\nimport NavBar from \"./components/NavBar\";\r\n\r\nclass App extends Component {\r\n    render() {\r\n        return (\r\n            <Router>\r\n                <div>\r\n                    <NavBar/>\r\n                    <Route path={\"/OpenLRDemo/\"} component={OpenLrDemo}  />\r\n                    <Route path={\"/DiscoveryDemo/\"} component={MainDemo} />\r\n                    {/*<Route path=\"/OpenStreetMapLinesView/\" component={ApiContainer} />*/}\r\n                </div>\r\n            </Router>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n// <ApiContainer/>\r\n// <OpenLrDemo/>\r\n// <MainDemo/>","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read http://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n    window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n        // The URL constructor is available in all browsers that support SW.\r\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n        if (publicUrl.origin !== window.location.origin) {\r\n            // Our service worker won't work if PUBLIC_URL is on a different origin\r\n            // from what our page is served on. This might happen if a CDN is used to\r\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n            return;\r\n        }\r\n\r\n        window.addEventListener('load', () => {\r\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n        if (isLocalhost) {\r\n            // This is running on localhost. Let's check if a service worker still exists or not.\r\n            checkValidServiceWorker(swUrl, config);\r\n\r\n            // Add some additional logging to localhost, pointing developers to the\r\n            // service worker/PWA documentation.\r\n            navigator.serviceWorker.ready.then(() => {\r\n                console.log(\r\n                'This web app is being served cache-first by a service ' +\r\n                'worker. To learn more, visit http://bit.ly/CRA-PWA'\r\n            );\r\n        })\r\n            ;\r\n        } else {\r\n            // Is not localhost. Just register service worker\r\n            registerValidSW(swUrl, config);\r\n        }\r\n    })\r\n        ;\r\n    }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n    navigator.serviceWorker\r\n        .register(swUrl)\r\n        .then(registration => {\r\n        registration.onupdatefound = () =>\r\n    {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n            return;\r\n        }\r\n        installingWorker.onstatechange = () =>\r\n        {\r\n            if (installingWorker.state === 'installed') {\r\n                if (navigator.serviceWorker.controller) {\r\n                    // At this point, the updated precached content has been fetched,\r\n                    // but the previous service worker will still serve the older\r\n                    // content until all client tabs are closed.\r\n                    console.log(\r\n                        'New content is available and will be used when all ' +\r\n                        'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\r\n                    );\r\n\r\n                    // Execute callback\r\n                    if (config && config.onUpdate) {\r\n                        config.onUpdate(registration);\r\n                    }\r\n                } else {\r\n                    // At this point, everything has been precached.\r\n                    // It's the perfect time to display a\r\n                    // \"Content is cached for offline use.\" message.\r\n                    console.log('Content is cached for offline use.');\r\n\r\n                    // Execute callback\r\n                    if (config && config.onSuccess) {\r\n                        config.onSuccess(registration);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        ;\r\n    }\r\n    ;\r\n}).catch(error => {\r\n        console.error('Error during service worker registration:', error);\r\n})\r\n    ;\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n    // Check if the service worker can be found. If it can't reload the page.\r\n    fetch(swUrl).then(response => {\r\n        // Ensure service worker exists, and that we really are getting a JS file.\r\n        const contentType = response.headers.get('content-type');\r\n    if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n    ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n            registration.unregister().then(() => {\r\n            window.location.reload();\r\n    })\r\n        ;\r\n    })\r\n        ;\r\n    } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n    }\r\n}).catch(() => {\r\n        console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n    );\r\n})\r\n    ;\r\n}\r\n\r\nexport function unregister() {\r\n    if ('serviceWorker' in navigator) {\r\n        navigator.serviceWorker.ready.then(registration => {\r\n            registration.unregister();\r\n    })\r\n        ;\r\n    }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport 'semantic-ui-css/semantic.min.css'\r\n\r\nReactDOM.render( < App />, document.getElementById('root')\r\n)\r\n;\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: http://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}